{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 84, "column": 0}, "map": {"version":3,"sources":["file:///Users/tanishqbedi/Documents/Projects/kageyama/lifeos/src/lib/session.ts"],"sourcesContent":["// src/lib/session.ts\nimport { SignJWT, jwtVerify } from 'jose';\nimport { cookies } from 'next/headers';\nimport { NextResponse, type NextRequest } from 'next/server'; // Corrected import for NextResponse\n\nconst JWT_SECRET_KEY = process.env.JWT_SECRET;\nconst JWT_COOKIE_NAME = 'lifeos_session_token';\nconst JWT_EXPIRATION_TIME = '30d'; // Session expiration time\n\nif (!JWT_SECRET_KEY) {\n  throw new Error('Please define the JWT_SECRET environment variable inside .env');\n}\n\nconst secret = new TextEncoder().encode(JWT_SECRET_KEY);\n\ninterface UserJWTPayload {\n  userId: string;\n  email: string;\n  // Add other non-sensitive user data you might want in the JWT\n  exp?: number; // Standard JWT expiration claim\n}\n\nexport async function encrypt(payload: UserJWTPayload): Promise<string> {\n  return await new SignJWT(payload)\n    .setProtectedHeader({ alg: 'HS256' })\n    .setIssuedAt()\n    .setExpirationTime(JWT_EXPIRATION_TIME)\n    .sign(secret);\n}\n\nexport async function decrypt(token: string): Promise<UserJWTPayload | null> {\n  try {\n    const { payload } = await jwtVerify<UserJWTPayload>(token, secret, {\n      algorithms: ['HS256'],\n    });\n    return payload;\n  } catch (error) {\n    console.error('JWT verification failed:', error);\n    return null;\n  }\n}\n\nexport async function createSession(userId: string, email: string) {\n  const expires = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days\n  const sessionToken = await encrypt({ userId, email, exp: expires.getTime() / 1000 });\n\n  cookies().set(JWT_COOKIE_NAME, sessionToken, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === 'production',\n    expires: expires,\n    sameSite: 'lax',\n    path: '/',\n  });\n  console.log(`Session created for user ${userId}, cookie set.`);\n}\n\nexport async function getSessionFromCookie(): Promise<UserJWTPayload | null> {\n  const sessionCookie = cookies().get(JWT_COOKIE_NAME)?.value;\n  if (!sessionCookie) {\n    return null;\n  }\n  return await decrypt(sessionCookie);\n}\n\nexport async function deleteSession() {\n  cookies().set(JWT_COOKIE_NAME, '', { expires: new Date(0), path: '/' });\n  console.log('Session cookie deleted.');\n}\n\n// This function is used by middleware to update the session cookie's expiration.\nexport async function updateSessionCookie(request: NextRequest): Promise<NextResponse | undefined> {\n  const sessionCookie = request.cookies.get(JWT_COOKIE_NAME)?.value;\n  let response = NextResponse.next({ request: { headers: request.headers } });\n\n  if (!sessionCookie) {\n    return response; // No session to update\n  }\n\n  const parsed = await decrypt(sessionCookie);\n  if (parsed?.userId && parsed.email) {\n    // Re-encrypt and set the cookie to refresh its expiration time\n    const expires = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days\n    const newSessionToken = await encrypt({ userId: parsed.userId, email: parsed.email, exp: expires.getTime() / 1000 });\n    \n    response.cookies.set(JWT_COOKIE_NAME, newSessionToken, {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      expires: expires,\n      sameSite: 'lax',\n      path: '/',\n    });\n    console.log('Session cookie updated for user', parsed.userId);\n  } else {\n    // Invalid session, clear it\n    response.cookies.set(JWT_COOKIE_NAME, '', { expires: new Date(0), path: '/' });\n  }\n  return response;\n}\n\n"],"names":[],"mappings":"AAAA,qBAAqB;;;;;;;;;AACrB;AAAA;AACA;AACA,kOAA8D,oCAAoC;;;;AAElG,MAAM,iBAAiB,QAAQ,GAAG,CAAC,UAAU;AAC7C,MAAM,kBAAkB;AACxB,MAAM,sBAAsB,OAAO,0BAA0B;AAE7D,IAAI,CAAC,gBAAgB;IACnB,MAAM,IAAI,MAAM;AAClB;AAEA,MAAM,SAAS,IAAI,cAAc,MAAM,CAAC;AASjC,eAAe,QAAQ,OAAuB;IACnD,OAAO,MAAM,IAAI,4JAAA,CAAA,UAAO,CAAC,SACtB,kBAAkB,CAAC;QAAE,KAAK;IAAQ,GAClC,WAAW,GACX,iBAAiB,CAAC,qBAClB,IAAI,CAAC;AACV;AAEO,eAAe,QAAQ,KAAa;IACzC,IAAI;QACF,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,CAAA,GAAA,8JAAA,CAAA,YAAS,AAAD,EAAkB,OAAO,QAAQ;YACjE,YAAY;gBAAC;aAAQ;QACvB;QACA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO;IACT;AACF;AAEO,eAAe,cAAc,MAAc,EAAE,KAAa;IAC/D,MAAM,UAAU,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,KAAK,KAAK,KAAK,OAAO,UAAU;IAC3E,MAAM,eAAe,MAAM,QAAQ;QAAE;QAAQ;QAAO,KAAK,QAAQ,OAAO,KAAK;IAAK;IAElF,CAAA,GAAA,iIAAA,CAAA,UAAO,AAAD,IAAI,GAAG,CAAC,iBAAiB,cAAc;QAC3C,UAAU;QACV,QAAQ,oDAAyB;QACjC,SAAS;QACT,UAAU;QACV,MAAM;IACR;IACA,QAAQ,GAAG,CAAC,CAAC,yBAAyB,EAAE,OAAO,aAAa,CAAC;AAC/D;AAEO,eAAe;IACpB,MAAM,gBAAgB,CAAA,GAAA,iIAAA,CAAA,UAAO,AAAD,IAAI,GAAG,CAAC,kBAAkB;IACtD,IAAI,CAAC,eAAe;QAClB,OAAO;IACT;IACA,OAAO,MAAM,QAAQ;AACvB;AAEO,eAAe;IACpB,CAAA,GAAA,iIAAA,CAAA,UAAO,AAAD,IAAI,GAAG,CAAC,iBAAiB,IAAI;QAAE,SAAS,IAAI,KAAK;QAAI,MAAM;IAAI;IACrE,QAAQ,GAAG,CAAC;AACd;AAGO,eAAe,oBAAoB,OAAoB;IAC5D,MAAM,gBAAgB,QAAQ,OAAO,CAAC,GAAG,CAAC,kBAAkB;IAC5D,IAAI,WAAW,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;QAAE,SAAS;YAAE,SAAS,QAAQ,OAAO;QAAC;IAAE;IAEzE,IAAI,CAAC,eAAe;QAClB,OAAO,UAAU,uBAAuB;IAC1C;IAEA,MAAM,SAAS,MAAM,QAAQ;IAC7B,IAAI,QAAQ,UAAU,OAAO,KAAK,EAAE;QAClC,+DAA+D;QAC/D,MAAM,UAAU,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,KAAK,KAAK,KAAK,OAAO,UAAU;QAC3E,MAAM,kBAAkB,MAAM,QAAQ;YAAE,QAAQ,OAAO,MAAM;YAAE,OAAO,OAAO,KAAK;YAAE,KAAK,QAAQ,OAAO,KAAK;QAAK;QAElH,SAAS,OAAO,CAAC,GAAG,CAAC,iBAAiB,iBAAiB;YACrD,UAAU;YACV,QAAQ,oDAAyB;YACjC,SAAS;YACT,UAAU;YACV,MAAM;QACR;QACA,QAAQ,GAAG,CAAC,mCAAmC,OAAO,MAAM;IAC9D,OAAO;QACL,4BAA4B;QAC5B,SAAS,OAAO,CAAC,GAAG,CAAC,iBAAiB,IAAI;YAAE,SAAS,IAAI,KAAK;YAAI,MAAM;QAAI;IAC9E;IACA,OAAO;AACT","debugId":null}},
    {"offset": {"line": 197, "column": 0}, "map": {"version":3,"sources":["file:///Users/tanishqbedi/Documents/Projects/kageyama/lifeos/src/app/api/auth/session/route.ts"],"sourcesContent":["// src/app/api/auth/session/route.ts\nimport { NextResponse } from 'next/server';\nimport { getSessionFromCookie } from '@/lib/session';\n\nexport async function GET() {\n  try {\n    const session = await getSessionFromCookie();\n\n    if (!session) {\n      return NextResponse.json({ user: null, message: 'No active session' }, { status: 200 });\n    }\n\n    // Optionally, you could re-verify against DB here if needed, but JWT verification should suffice\n    return NextResponse.json({ user: { id: session.userId, email: session.email }, message: 'Session active' }, { status: 200 });\n\n  } catch (error) {\n    console.error('Session check API error:', error);\n    return NextResponse.json({ user: null, message: 'Internal server error while checking session' }, { status: 500 });\n  }\n}\n\n"],"names":[],"mappings":"AAAA,oCAAoC;;;;AACpC;AACA;;;AAEO,eAAe;IACpB,IAAI;QACF,MAAM,UAAU,MAAM,CAAA,GAAA,uHAAA,CAAA,uBAAoB,AAAD;QAEzC,IAAI,CAAC,SAAS;YACZ,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,MAAM;gBAAM,SAAS;YAAoB,GAAG;gBAAE,QAAQ;YAAI;QACvF;QAEA,iGAAiG;QACjG,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,MAAM;gBAAE,IAAI,QAAQ,MAAM;gBAAE,OAAO,QAAQ,KAAK;YAAC;YAAG,SAAS;QAAiB,GAAG;YAAE,QAAQ;QAAI;IAE5H,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,MAAM;YAAM,SAAS;QAA+C,GAAG;YAAE,QAAQ;QAAI;IAClH;AACF","debugId":null}}]
}