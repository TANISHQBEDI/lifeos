{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///Users/tanishqbedi/Documents/Projects/kageyama/lifeos/src/lib/mongodb.ts"],"sourcesContent":["// src/lib/mongodb.ts\nimport mongoose from 'mongoose';\n\nconst MONGODB_URL = process.env.MONGODB_URL || \"mongodb+srv://fowlstar1:DtcGkysHjBM7bsZY@study.mcq95hq.mongodb.net/?retryWrites=true&w=majority&appName=study\";\nconst DATABASE_NAME = process.env.DATABASE_NAME || 'lifeos_db'; // You can still specify a DB name, Mongoose will use it.\n\nif (!MONGODB_URL) {\n  throw new Error('Please define the MONGODB_URL environment variable inside .env or ensure it is hardcoded correctly.');\n}\n\n// Connection options for Mongoose, incorporating the serverApi settings\nconst clientOptions: mongoose.ConnectOptions = {\n  serverApi: { version: '1', strict: true, deprecationErrors: true },\n  dbName: DATABASE_NAME, // Specify the database name here\n};\n\n// Global variable to cache the Mongoose connection\n// In development, Next.js clears Node.js cache on every edit, so we need to cache the connection on the global object.\n// In production, this isn't necessary as the module is loaded once.\ndeclare global {\n  // eslint-disable-next-line no-var\n  var mongooseConnection: { conn: typeof mongoose | null; promise: Promise<typeof mongoose> | null };\n}\n\nlet cached = global.mongooseConnection;\n\nif (!cached) {\n  cached = global.mongooseConnection = { conn: null, promise: null };\n}\n\nexport async function connectToDatabase(): Promise<typeof mongoose> {\n  if (cached.conn) {\n    console.log('Using cached Mongoose connection.');\n    return cached.conn;\n  }\n\n  if (!cached.promise) {\n    console.log('Creating new Mongoose connection...');\n    cached.promise = mongoose.connect(MONGODB_URL, clientOptions).then(async (mongooseInstance) => {\n      console.log(\"Pinged your deployment. You successfully connected to MongoDB via Mongoose!\");\n      try {\n        // Optional: Ping after connection to confirm\n        await mongooseInstance.connection.db.admin().command({ ping: 1 });\n        console.log(\"MongoDB admin ping successful.\");\n      } catch(pingError) {\n        console.error(\"MongoDB admin ping failed after connection:\", pingError);\n        // Depending on severity, you might want to throw or handle this\n      }\n      return mongooseInstance;\n    }).catch(err => {\n        console.error('Mongoose connection error:', err);\n        cached.promise = null; // Reset promise on error so next attempt tries again\n        throw err; // Re-throw error to be caught by caller\n    });\n  }\n\n  try {\n    cached.conn = await cached.promise;\n  } catch (e) {\n    cached.promise = null; // Ensure promise is cleared on error to allow retries\n    throw e;\n  }\n  \n  return cached.conn;\n}\n\n// Optional: A function to get the db instance directly if already connected (Mongoose connection object)\nexport function getMongooseConnection(): typeof mongoose {\n  if (!cached.conn) {\n    throw new Error('Database not connected. Call connectToDatabase first.');\n  }\n  return cached.conn;\n}\n\n"],"names":[],"mappings":"AAAA,qBAAqB;;;;;AACrB;;AAEA,MAAM,cAAc,QAAQ,GAAG,CAAC,WAAW,IAAI;AAC/C,MAAM,gBAAgB,QAAQ,GAAG,CAAC,aAAa,IAAI,aAAa,yDAAyD;AAEzH,uCAAkB;;AAElB;AAEA,wEAAwE;AACxE,MAAM,gBAAyC;IAC7C,WAAW;QAAE,SAAS;QAAK,QAAQ;QAAM,mBAAmB;IAAK;IACjE,QAAQ;AACV;AAUA,IAAI,SAAS,OAAO,kBAAkB;AAEtC,IAAI,CAAC,QAAQ;IACX,SAAS,OAAO,kBAAkB,GAAG;QAAE,MAAM;QAAM,SAAS;IAAK;AACnE;AAEO,eAAe;IACpB,IAAI,OAAO,IAAI,EAAE;QACf,QAAQ,GAAG,CAAC;QACZ,OAAO,OAAO,IAAI;IACpB;IAEA,IAAI,CAAC,OAAO,OAAO,EAAE;QACnB,QAAQ,GAAG,CAAC;QACZ,OAAO,OAAO,GAAG,yGAAA,CAAA,UAAQ,CAAC,OAAO,CAAC,aAAa,eAAe,IAAI,CAAC,OAAO;YACxE,QAAQ,GAAG,CAAC;YACZ,IAAI;gBACF,6CAA6C;gBAC7C,MAAM,iBAAiB,UAAU,CAAC,EAAE,CAAC,KAAK,GAAG,OAAO,CAAC;oBAAE,MAAM;gBAAE;gBAC/D,QAAQ,GAAG,CAAC;YACd,EAAE,OAAM,WAAW;gBACjB,QAAQ,KAAK,CAAC,+CAA+C;YAC7D,gEAAgE;YAClE;YACA,OAAO;QACT,GAAG,KAAK,CAAC,CAAA;YACL,QAAQ,KAAK,CAAC,8BAA8B;YAC5C,OAAO,OAAO,GAAG,MAAM,qDAAqD;YAC5E,MAAM,KAAK,wCAAwC;QACvD;IACF;IAEA,IAAI;QACF,OAAO,IAAI,GAAG,MAAM,OAAO,OAAO;IACpC,EAAE,OAAO,GAAG;QACV,OAAO,OAAO,GAAG,MAAM,sDAAsD;QAC7E,MAAM;IACR;IAEA,OAAO,OAAO,IAAI;AACpB;AAGO,SAAS;IACd,IAAI,CAAC,OAAO,IAAI,EAAE;QAChB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO,OAAO,IAAI;AACpB","debugId":null}},
    {"offset": {"line": 150, "column": 0}, "map": {"version":3,"sources":["file:///Users/tanishqbedi/Documents/Projects/kageyama/lifeos/src/models/User.ts"],"sourcesContent":["// src/models/User.ts\nimport mongoose, { Schema, Document, models, Model } from 'mongoose';\n\n// Define an interface representing a document in MongoDB.\nexport interface IUser extends Document {\n  email: string;\n  hashedPassword?: string; // Optional because it might not be present on client-side user objects\n  createdAt: Date;\n  updatedAt: Date;\n  // Add any other user fields you might need\n  // For example:\n  // name?: string;\n  // profilePictureUrl?: string;\n}\n\n// Define the schema corresponding to the document interface.\nconst UserSchema: Schema<IUser> = new Schema(\n  {\n    email: {\n      type: String,\n      required: [true, 'Please provide an email for this user.'],\n      unique: true, // Ensure emails are unique\n      lowercase: true, // Store emails in lowercase\n      trim: true, // Remove whitespace from both ends of an email\n      match: [/.+\\@.+\\..+/, 'Please fill a valid email address'], // Basic email validation\n    },\n    hashedPassword: {\n      type: String,\n      required: [true, 'Please provide a password for this user.'],\n      select: false, // By default, do not return hashedPassword in queries\n    },\n    // You can add other fields here like name, profilePictureUrl, etc.\n    // name: {\n    //   type: String,\n    //   required: false,\n    //   trim: true,\n    // },\n  },\n  {\n    // Mongoose automatically adds createdAt and updatedAt fields\n    timestamps: true,\n  }\n);\n\n// Prevent model overwrite in Next.js HMR\nconst User: Model<IUser> = models.User || mongoose.model<IUser>('User', UserSchema);\n\nexport default User;\n\n"],"names":[],"mappings":"AAAA,qBAAqB;;;;AACrB;;AAcA,6DAA6D;AAC7D,MAAM,aAA4B,IAAI,yGAAA,CAAA,SAAM,CAC1C;IACE,OAAO;QACL,MAAM;QACN,UAAU;YAAC;YAAM;SAAyC;QAC1D,QAAQ;QACR,WAAW;QACX,MAAM;QACN,OAAO;YAAC;YAAc;SAAoC;IAC5D;IACA,gBAAgB;QACd,MAAM;QACN,UAAU;YAAC;YAAM;SAA2C;QAC5D,QAAQ;IACV;AAOF,GACA;IACE,6DAA6D;IAC7D,YAAY;AACd;AAGF,yCAAyC;AACzC,MAAM,OAAqB,yGAAA,CAAA,SAAM,CAAC,IAAI,IAAI,yGAAA,CAAA,UAAQ,CAAC,KAAK,CAAQ,QAAQ;uCAEzD","debugId":null}},
    {"offset": {"line": 217, "column": 0}, "map": {"version":3,"sources":["file:///Users/tanishqbedi/Documents/Projects/kageyama/lifeos/src/lib/session.ts"],"sourcesContent":["// src/lib/session.ts\nimport { SignJWT, jwtVerify } from 'jose';\nimport { cookies } from 'next/headers';\nimport { NextResponse, type NextRequest } from 'next/server'; // Corrected import for NextResponse\n\nconst JWT_SECRET_KEY = process.env.JWT_SECRET;\nconst JWT_COOKIE_NAME = 'lifeos_session_token';\nconst JWT_EXPIRATION_TIME = '30d'; // Session expiration time\n\nif (!JWT_SECRET_KEY) {\n  throw new Error('Please define the JWT_SECRET environment variable inside .env');\n}\n\nconst secret = new TextEncoder().encode(JWT_SECRET_KEY);\n\ninterface UserJWTPayload {\n  userId: string;\n  email: string;\n  // Add other non-sensitive user data you might want in the JWT\n  exp?: number; // Standard JWT expiration claim\n}\n\nexport async function encrypt(payload: UserJWTPayload): Promise<string> {\n  return await new SignJWT(payload)\n    .setProtectedHeader({ alg: 'HS256' })\n    .setIssuedAt()\n    .setExpirationTime(JWT_EXPIRATION_TIME)\n    .sign(secret);\n}\n\nexport async function decrypt(token: string): Promise<UserJWTPayload | null> {\n  try {\n    const { payload } = await jwtVerify<UserJWTPayload>(token, secret, {\n      algorithms: ['HS256'],\n    });\n    return payload;\n  } catch (error) {\n    console.error('JWT verification failed:', error);\n    return null;\n  }\n}\n\nexport async function createSession(userId: string, email: string) {\n  const expires = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days\n  const sessionToken = await encrypt({ userId, email, exp: expires.getTime() / 1000 });\n\n  cookies().set(JWT_COOKIE_NAME, sessionToken, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === 'production',\n    expires: expires,\n    sameSite: 'lax',\n    path: '/',\n  });\n  console.log(`Session created for user ${userId}, cookie set.`);\n}\n\nexport async function getSessionFromCookie(): Promise<UserJWTPayload | null> {\n  const sessionCookie = cookies().get(JWT_COOKIE_NAME)?.value;\n  if (!sessionCookie) {\n    return null;\n  }\n  return await decrypt(sessionCookie);\n}\n\nexport async function deleteSession() {\n  cookies().set(JWT_COOKIE_NAME, '', { expires: new Date(0), path: '/' });\n  console.log('Session cookie deleted.');\n}\n\n// This function is used by middleware to update the session cookie's expiration.\nexport async function updateSessionCookie(request: NextRequest): Promise<NextResponse | undefined> {\n  const sessionCookie = request.cookies.get(JWT_COOKIE_NAME)?.value;\n  let response = NextResponse.next({ request: { headers: request.headers } });\n\n  if (!sessionCookie) {\n    return response; // No session to update\n  }\n\n  const parsed = await decrypt(sessionCookie);\n  if (parsed?.userId && parsed.email) {\n    // Re-encrypt and set the cookie to refresh its expiration time\n    const expires = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days\n    const newSessionToken = await encrypt({ userId: parsed.userId, email: parsed.email, exp: expires.getTime() / 1000 });\n    \n    response.cookies.set(JWT_COOKIE_NAME, newSessionToken, {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      expires: expires,\n      sameSite: 'lax',\n      path: '/',\n    });\n    console.log('Session cookie updated for user', parsed.userId);\n  } else {\n    // Invalid session, clear it\n    response.cookies.set(JWT_COOKIE_NAME, '', { expires: new Date(0), path: '/' });\n  }\n  return response;\n}\n\n"],"names":[],"mappings":"AAAA,qBAAqB;;;;;;;;;AACrB;AAAA;AACA;AACA,kOAA8D,oCAAoC;;;;AAElG,MAAM,iBAAiB,QAAQ,GAAG,CAAC,UAAU;AAC7C,MAAM,kBAAkB;AACxB,MAAM,sBAAsB,OAAO,0BAA0B;AAE7D,IAAI,CAAC,gBAAgB;IACnB,MAAM,IAAI,MAAM;AAClB;AAEA,MAAM,SAAS,IAAI,cAAc,MAAM,CAAC;AASjC,eAAe,QAAQ,OAAuB;IACnD,OAAO,MAAM,IAAI,4JAAA,CAAA,UAAO,CAAC,SACtB,kBAAkB,CAAC;QAAE,KAAK;IAAQ,GAClC,WAAW,GACX,iBAAiB,CAAC,qBAClB,IAAI,CAAC;AACV;AAEO,eAAe,QAAQ,KAAa;IACzC,IAAI;QACF,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,CAAA,GAAA,8JAAA,CAAA,YAAS,AAAD,EAAkB,OAAO,QAAQ;YACjE,YAAY;gBAAC;aAAQ;QACvB;QACA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO;IACT;AACF;AAEO,eAAe,cAAc,MAAc,EAAE,KAAa;IAC/D,MAAM,UAAU,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,KAAK,KAAK,KAAK,OAAO,UAAU;IAC3E,MAAM,eAAe,MAAM,QAAQ;QAAE;QAAQ;QAAO,KAAK,QAAQ,OAAO,KAAK;IAAK;IAElF,CAAA,GAAA,iIAAA,CAAA,UAAO,AAAD,IAAI,GAAG,CAAC,iBAAiB,cAAc;QAC3C,UAAU;QACV,QAAQ,oDAAyB;QACjC,SAAS;QACT,UAAU;QACV,MAAM;IACR;IACA,QAAQ,GAAG,CAAC,CAAC,yBAAyB,EAAE,OAAO,aAAa,CAAC;AAC/D;AAEO,eAAe;IACpB,MAAM,gBAAgB,CAAA,GAAA,iIAAA,CAAA,UAAO,AAAD,IAAI,GAAG,CAAC,kBAAkB;IACtD,IAAI,CAAC,eAAe;QAClB,OAAO;IACT;IACA,OAAO,MAAM,QAAQ;AACvB;AAEO,eAAe;IACpB,CAAA,GAAA,iIAAA,CAAA,UAAO,AAAD,IAAI,GAAG,CAAC,iBAAiB,IAAI;QAAE,SAAS,IAAI,KAAK;QAAI,MAAM;IAAI;IACrE,QAAQ,GAAG,CAAC;AACd;AAGO,eAAe,oBAAoB,OAAoB;IAC5D,MAAM,gBAAgB,QAAQ,OAAO,CAAC,GAAG,CAAC,kBAAkB;IAC5D,IAAI,WAAW,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;QAAE,SAAS;YAAE,SAAS,QAAQ,OAAO;QAAC;IAAE;IAEzE,IAAI,CAAC,eAAe;QAClB,OAAO,UAAU,uBAAuB;IAC1C;IAEA,MAAM,SAAS,MAAM,QAAQ;IAC7B,IAAI,QAAQ,UAAU,OAAO,KAAK,EAAE;QAClC,+DAA+D;QAC/D,MAAM,UAAU,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,KAAK,KAAK,KAAK,OAAO,UAAU;QAC3E,MAAM,kBAAkB,MAAM,QAAQ;YAAE,QAAQ,OAAO,MAAM;YAAE,OAAO,OAAO,KAAK;YAAE,KAAK,QAAQ,OAAO,KAAK;QAAK;QAElH,SAAS,OAAO,CAAC,GAAG,CAAC,iBAAiB,iBAAiB;YACrD,UAAU;YACV,QAAQ,oDAAyB;YACjC,SAAS;YACT,UAAU;YACV,MAAM;QACR;QACA,QAAQ,GAAG,CAAC,mCAAmC,OAAO,MAAM;IAC9D,OAAO;QACL,4BAA4B;QAC5B,SAAS,OAAO,CAAC,GAAG,CAAC,iBAAiB,IAAI;YAAE,SAAS,IAAI,KAAK;YAAI,MAAM;QAAI;IAC9E;IACA,OAAO;AACT","debugId":null}},
    {"offset": {"line": 330, "column": 0}, "map": {"version":3,"sources":["file:///Users/tanishqbedi/Documents/Projects/kageyama/lifeos/src/app/api/auth/login/route.ts"],"sourcesContent":["// src/app/api/auth/login/route.ts\nimport { NextResponse, NextRequest } from 'next/server';\nimport bcrypt from 'bcrypt';\nimport { connectToDatabase } from '@/lib/mongodb';\nimport User from '@/models/User'; // Import Mongoose User model\nimport { createSession } from '@/lib/session';\n\nexport async function POST(req: NextRequest) {\n  try {\n    const { email, password } = await req.json();\n\n    if (!email || !password) {\n      return NextResponse.json({ message: 'Email and password are required' }, { status: 400 });\n    }\n\n    await connectToDatabase(); // Establishes Mongoose connection\n\n    // Explicitly select hashedPassword as it has `select: false` in the schema\n    const user = await User.findOne({ email: email.toLowerCase() }).select('+hashedPassword');\n\n    if (!user) {\n      return NextResponse.json({ message: 'Invalid email or password' }, { status: 401 });\n    }\n\n    // This check is crucial: if hashedPassword is not retrieved, user.hashedPassword will be undefined.\n    if (!user.hashedPassword) {\n        console.error(`Login failed: No hashed password retrieved for user ${user.email}. This might indicate a schema or query issue.`);\n        return NextResponse.json({ message: 'Authentication error. Please contact support.' }, { status: 500 });\n    }\n\n    const isPasswordValid = await bcrypt.compare(password, user.hashedPassword);\n\n    if (!isPasswordValid) {\n      return NextResponse.json({ message: 'Invalid email or password' }, { status: 401 });\n    }\n\n    const userId = user._id.toString();\n    await createSession(userId, user.email); // Create JWT session\n\n    return NextResponse.json({ \n        message: 'Login successful!', \n        user: { id: userId, email: user.email } \n    }, { status: 200 });\n\n  } catch (error) {\n    console.error('Login API error:', error);\n    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });\n  }\n}\n"],"names":[],"mappings":"AAAA,kCAAkC;;;;AAClC;AACA;AACA;AACA,gNAAkC,6BAA6B;AAC/D;;;;;;AAEO,eAAe,KAAK,GAAgB;IACzC,IAAI;QACF,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG,MAAM,IAAI,IAAI;QAE1C,IAAI,CAAC,SAAS,CAAC,UAAU;YACvB,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;YAAkC,GAAG;gBAAE,QAAQ;YAAI;QACzF;QAEA,MAAM,CAAA,GAAA,uHAAA,CAAA,oBAAiB,AAAD,KAAK,kCAAkC;QAE7D,2EAA2E;QAC3E,MAAM,OAAO,MAAM,uHAAA,CAAA,UAAI,CAAC,OAAO,CAAC;YAAE,OAAO,MAAM,WAAW;QAAG,GAAG,MAAM,CAAC;QAEvE,IAAI,CAAC,MAAM;YACT,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;YAA4B,GAAG;gBAAE,QAAQ;YAAI;QACnF;QAEA,oGAAoG;QACpG,IAAI,CAAC,KAAK,cAAc,EAAE;YACtB,QAAQ,KAAK,CAAC,CAAC,oDAAoD,EAAE,KAAK,KAAK,CAAC,8CAA8C,CAAC;YAC/H,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;YAAgD,GAAG;gBAAE,QAAQ;YAAI;QACzG;QAEA,MAAM,kBAAkB,MAAM,qGAAA,CAAA,UAAM,CAAC,OAAO,CAAC,UAAU,KAAK,cAAc;QAE1E,IAAI,CAAC,iBAAiB;YACpB,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;YAA4B,GAAG;gBAAE,QAAQ;YAAI;QACnF;QAEA,MAAM,SAAS,KAAK,GAAG,CAAC,QAAQ;QAChC,MAAM,CAAA,GAAA,uHAAA,CAAA,gBAAa,AAAD,EAAE,QAAQ,KAAK,KAAK,GAAG,qBAAqB;QAE9D,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACrB,SAAS;YACT,MAAM;gBAAE,IAAI;gBAAQ,OAAO,KAAK,KAAK;YAAC;QAC1C,GAAG;YAAE,QAAQ;QAAI;IAEnB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,oBAAoB;QAClC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,SAAS;QAAwB,GAAG;YAAE,QAAQ;QAAI;IAC/E;AACF","debugId":null}}]
}