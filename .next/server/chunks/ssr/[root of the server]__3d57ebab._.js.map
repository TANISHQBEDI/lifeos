{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 215, "column": 0}, "map": {"version":3,"sources":["file:///Users/tanishqbedi/Documents/Projects/kageyama/lifeos/src/ai/ai-instance.ts"],"sourcesContent":["import {genkit} from 'genkit';\nimport {googleAI} from '@genkit-ai/googleai';\n\n// Ensure the API key is being read from the environment variable\nconst apiKey = process.env.GOOGLE_GENAI_API_KEY;\n\nif (!apiKey) {\n  console.warn(\n    'GOOGLE_GENAI_API_KEY is not set. AI features will not work. Please set it in your .env file.'\n  );\n}\n\nexport const ai = genkit({\n  promptDir: './prompts', // This might not be used if prompts are defined in code\n  plugins: [\n    googleAI({\n      apiKey: apiKey, // Pass the apiKey variable here\n    }),\n  ],\n  // Default model for general text generation, can be overridden in specific prompts/flows\n  model: 'googleai/gemini-1.5-flash', // Changed to 1.5-flash as 2.0-flash is experimental for image gen\n});\n"],"names":[],"mappings":";;;AAAA;AAAA;AACA;AAAA;;;AAEA,iEAAiE;AACjE,MAAM,SAAS,QAAQ,GAAG,CAAC,oBAAoB;AAE/C,IAAI,CAAC,QAAQ;IACX,QAAQ,IAAI,CACV;AAEJ;AAEO,MAAM,KAAK,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,EAAE;IACvB,WAAW;IACX,SAAS;QACP,CAAA,GAAA,2KAAA,CAAA,WAAQ,AAAD,EAAE;YACP,QAAQ;QACV;KACD;IACD,yFAAyF;IACzF,OAAO;AACT","debugId":null}},
    {"offset": {"line": 245, "column": 0}, "map": {"version":3,"sources":["file:///Users/tanishqbedi/Documents/Projects/kageyama/lifeos/src/ai/flows/goal-breakdown-flow.ts"],"sourcesContent":["\n'use server';\n/**\n * @fileOverview AI-powered goal breakdown into actionable tasks.\n *\n * - breakDownGoalIntoTasks - Function to generate tasks from a goal description.\n * - BreakDownGoalInput - Input type for the breakDownGoalIntoTasks function.\n * - BreakDownGoalOutput - Return type for the breakDownGoalIntoTasks function.\n */\n\nimport { ai } from '@/ai/ai-instance';\nimport { z } from 'genkit';\n\n// --- Input Schema ---\nconst BreakDownGoalInputSchema = z.object({\n  goalName: z.string().describe('The name or title of the goal.'),\n  goalDescription: z.string().optional().describe('A detailed description of the goal (optional but recommended).'),\n  // Could add more context later, like existing tasks, user preferences etc.\n});\nexport type BreakDownGoalInput = z.infer<typeof BreakDownGoalInputSchema>;\n\n// --- Output Schema ---\nconst BreakDownGoalOutputSchema = z.object({\n  tasks: z.array(z.string()).describe('An array of suggested actionable task descriptions (strings) to achieve the goal.'),\n});\nexport type BreakDownGoalOutput = z.infer<typeof BreakDownGoalOutputSchema>;\n\n// --- Exported Wrapper Function ---\nexport async function breakDownGoalIntoTasks(input: BreakDownGoalInput): Promise<BreakDownGoalOutput> {\n  console.log(`[breakDownGoalIntoTasks] Request received for goal: ${input.goalName}`);\n  try {\n      const result = await breakDownGoalFlow(input);\n      console.log(`[breakDownGoalIntoTasks] Flow completed. Generated ${result.tasks?.length ?? 0} tasks.`);\n      return result;\n  } catch (error) {\n      console.error('[breakDownGoalIntoTasks] Error calling flow:', error);\n      throw error; // Re-throw for the calling component\n  }\n}\n\n// --- AI Prompt Definition ---\nconst prompt = ai.definePrompt({\n  name: 'breakDownGoalPrompt',\n  input: {\n    schema: BreakDownGoalInputSchema,\n  },\n  output: {\n    schema: BreakDownGoalOutputSchema,\n    format: 'json' // Ensure structured JSON output\n  },\n  prompt: `You are an expert productivity assistant specializing in breaking down goals into smaller, actionable tasks.\n\n  Goal Name: {{{goalName}}}\n  {{#if goalDescription}}\n  Goal Description: {{{goalDescription}}}\n  {{/if}}\n\n  Based on the provided goal name and description, generate a list of specific, actionable tasks that need to be completed to achieve this goal.\n  Each task should be a clear, concise instruction starting with an action verb (e.g., \"Research...\", \"Draft...\", \"Schedule...\", \"Complete...\").\n  Generate a reasonable number of tasks (typically 3-10) that represent the key steps. Avoid being overly granular or too high-level.\n\n  Respond ONLY with a JSON object containing a single key \"tasks\", which is an array of strings representing the task descriptions. Do not include any introductory text, explanations, or markdown formatting.\n\n  Example Input:\n  Goal Name: \"Learn React Basics\"\n  Goal Description: \"Understand core React concepts like components, state, props, and hooks to build simple web applications.\"\n\n  Example Output:\n  {\n    \"tasks\": [\n      \"Complete the official React tutorial (react.dev)\",\n      \"Build a simple counter application using useState hook\",\n      \"Create a component that accepts and displays props\",\n      \"Learn about conditional rendering in React\",\n      \"Experiment with the useEffect hook for side effects\",\n      \"Read documentation on React Router for navigation\"\n    ]\n  }\n\n  Now, generate the tasks for the provided goal.\n  `,\n  // Consider using a slightly more capable model if needed, but flash should be okay\n  // model: 'googleai/gemini-1.5-flash',\n});\n\n// --- Genkit Flow Definition ---\nconst breakDownGoalFlow = ai.defineFlow<\n  typeof BreakDownGoalInputSchema,\n  typeof BreakDownGoalOutputSchema\n>({\n  name: 'breakDownGoalFlow',\n  inputSchema: BreakDownGoalInputSchema,\n  outputSchema: BreakDownGoalOutputSchema,\n}, async (input) => {\n  console.log('[breakDownGoalFlow] Starting flow execution...');\n  try {\n    const { output, usage } = await prompt(input);\n    console.log('[breakDownGoalFlow] AI prompt call completed. Usage:', usage);\n\n    if (!output || !Array.isArray(output.tasks)) {\n      console.error('[breakDownGoalFlow] AI failed to return a valid response structure. Output:', output);\n      throw new Error(\"AI failed to generate tasks. Invalid response format.\");\n    }\n\n     // Filter out any empty strings just in case\n     const validTasks = output.tasks.filter(task => typeof task === 'string' && task.trim() !== '');\n\n    console.log(`[breakDownGoalFlow] Task generation successful. Found ${validTasks.length} valid tasks.`);\n    return { tasks: validTasks };\n\n  } catch (error) {\n    console.error('[breakDownGoalFlow] Error during prompt execution:', error);\n    throw new Error(`AI prompt failed: ${error instanceof Error ? error.message : String(error)}`);\n  }\n});\n\n// Wrapper function breakDownGoalIntoTasks is exported for use in server actions.\n"],"names":[],"mappings":";;;;;AAEA;;;;;;CAMC,GAED;AACA;AAAA;;;;;;AAEA,uBAAuB;AACvB,MAAM,2BAA2B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACxC,UAAU,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC9B,iBAAiB,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;AAElD;AAGA,wBAAwB;AACxB,MAAM,4BAA4B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACzC,OAAO,uIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,uIAAA,CAAA,IAAC,CAAC,MAAM,IAAI,QAAQ,CAAC;AACtC;AAIO,eAAe,uCAAoB,GAApB,uBAAuB,KAAyB;IACpE,QAAQ,GAAG,CAAC,CAAC,oDAAoD,EAAE,MAAM,QAAQ,EAAE;IACnF,IAAI;QACA,MAAM,SAAS,MAAM,kBAAkB;QACvC,QAAQ,GAAG,CAAC,CAAC,mDAAmD,EAAE,OAAO,KAAK,EAAE,UAAU,EAAE,OAAO,CAAC;QACpG,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,gDAAgD;QAC9D,MAAM,OAAO,qCAAqC;IACtD;AACF;AAEA,+BAA+B;AAC/B,MAAM,SAAS,2HAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QACL,QAAQ;IACV;IACA,QAAQ;QACN,QAAQ;QACR,QAAQ,OAAO,gCAAgC;IACjD;IACA,QAAQ,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA8BT,CAAC;AAGH;AAEA,iCAAiC;AACjC,MAAM,oBAAoB,2HAAA,CAAA,KAAE,CAAC,UAAU,CAGrC;IACA,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GAAG,OAAO;IACR,QAAQ,GAAG,CAAC;IACZ,IAAI;QACF,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,OAAO;QACvC,QAAQ,GAAG,CAAC,wDAAwD;QAEpE,IAAI,CAAC,UAAU,CAAC,MAAM,OAAO,CAAC,OAAO,KAAK,GAAG;YAC3C,QAAQ,KAAK,CAAC,+EAA+E;YAC7F,MAAM,IAAI,MAAM;QAClB;QAEC,4CAA4C;QAC5C,MAAM,aAAa,OAAO,KAAK,CAAC,MAAM,CAAC,CAAA,OAAQ,OAAO,SAAS,YAAY,KAAK,IAAI,OAAO;QAE5F,QAAQ,GAAG,CAAC,CAAC,sDAAsD,EAAE,WAAW,MAAM,CAAC,aAAa,CAAC;QACrG,OAAO;YAAE,OAAO;QAAW;IAE7B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,sDAAsD;QACpE,MAAM,IAAI,MAAM,CAAC,kBAAkB,EAAE,iBAAiB,QAAQ,MAAM,OAAO,GAAG,OAAO,QAAQ;IAC/F;AACF,IAEA,iFAAiF;;;IAxF3D;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 362, "column": 0}, "map": {"version":3,"sources":["file:///Users/tanishqbedi/Documents/Projects/kageyama/lifeos/src/ai/flows/generate-flashcards.ts"],"sourcesContent":["\n'use server';\n/**\n * @fileOverview AI-powered flashcard generation from PDF content.\n *\n * - generateFlashcardsFromPdf - A function that generates flashcards from a PDF data URI.\n * - GenerateFlashcardsInput - The input type for the generateFlashcardsFromPdf function.\n * - GenerateFlashcardsOutput - The return type for the generateFlashcardsFromPdf function.\n * - Flashcard - Type definition for a single flashcard.\n */\n\nimport {ai} from '@/ai/ai-instance';\nimport {z} from 'genkit';\n\n// Define schema for a single flashcard (internal, not exported)\nconst FlashcardSchema = z.object({\n  question: z.string().describe('The question or term on the front of the flashcard.'),\n  answer: z.string().describe('The answer or definition on the back of the flashcard.'),\n});\nexport type Flashcard = z.infer<typeof FlashcardSchema>; // Export the type\n\n// Define input schema (internal, not exported)\nconst GenerateFlashcardsInputSchema = z.object({\n  pdfDataUri: z\n    .string()\n    .describe(\n      \"The content of the PDF file, as a data URI that must include a MIME type (application/pdf) and use Base64 encoding. Expected format: 'data:application/pdf;base64,<encoded_data>'.\"\n    ),\n   instructions: z\n    .string()\n    .optional()\n    .describe('Optional custom instructions for the flashcard generation process (e.g., specific topics, difficulty).'),\n});\nexport type GenerateFlashcardsInput = z.infer<typeof GenerateFlashcardsInputSchema>; // Export the type\n\n// Define output schema (internal, not exported)\nconst GenerateFlashcardsOutputSchema = z.object({\n  flashcards: z.array(FlashcardSchema).describe('An array of generated flashcards.'),\n});\nexport type GenerateFlashcardsOutput = z.infer<typeof GenerateFlashcardsOutputSchema>; // Export the type\n\n// Exported wrapper function\nexport async function generateFlashcardsFromPdf(input: GenerateFlashcardsInput): Promise<GenerateFlashcardsOutput> {\n  console.log('[generateFlashcardsFromPdf] Received request. Validating input...');\n  // Validate that the data URI is for a PDF\n  if (!input.pdfDataUri || !input.pdfDataUri.startsWith('data:application/pdf;base64,')) {\n     console.error('[generateFlashcardsFromPdf] Invalid input: pdfDataUri is missing or not a base64 encoded PDF data URI.', input.pdfDataUri?.substring(0, 50));\n    throw new Error('Invalid input: pdfDataUri must be a base64 encoded PDF data URI starting with \"data:application/pdf;base64,\".');\n  }\n   console.log('[generateFlashcardsFromPdf] Input validated. Calling generateFlashcardsFlow...');\n  try {\n      const result = await generateFlashcardsFlow(input);\n      console.log(`[generateFlashcardsFromPdf] Flow completed successfully. Returning ${result.flashcards?.length ?? 0} cards.`);\n      return result;\n  } catch (error) {\n       console.error('[generateFlashcardsFromPdf] Error calling generateFlashcardsFlow:', error);\n       // Re-throw the error to be caught by the calling component\n       throw error;\n  }\n}\n\n// Define the prompt\nconst prompt = ai.definePrompt({\n  name: 'generateFlashcardsPrompt',\n  input: {\n    schema: GenerateFlashcardsInputSchema\n  },\n  output: {\n    schema: GenerateFlashcardsOutputSchema,\n    format: 'json' // Ensure the model outputs structured JSON\n  },\n  prompt: `You are an expert in creating effective study materials, specifically flashcards, from PDF documents.\n\n  Analyze the provided PDF document and generate a comprehensive set of flashcards. Each flashcard MUST have a clear question/term on the front and a corresponding accurate answer/definition on the back.\n  Focus on extracting **all** relevant key terms, definitions, concepts, important facts, and potential test questions found in the document.\n  Generate as many high-quality flashcards as the content supports. Do not impose an artificial limit on the number of cards.\n\n  {{#if instructions}}\n  Follow these specific instructions: {{{instructions}}}\n  {{else}}\n  Generate flashcards covering all main points and important details of the document.\n  {{/if}}\n\n  PDF Content:\n  {{media url=pdfDataUri}}\n\n  Generate the flashcards now based on the PDF content and instructions. Ensure the output is an array of objects, each with a 'question' and 'answer' field. Respond ONLY with the JSON object containing the 'flashcards' array. Do not include any introductory text or markdown formatting around the JSON.\n  `,\n  // Specify the model capable of processing PDFs (Gemini 1.5 Flash or Pro)\n  model: 'googleai/gemini-1.5-flash',\n});\n\n// Define the flow (internal, not exported directly for server actions)\nconst generateFlashcardsFlow = ai.defineFlow<\n  typeof GenerateFlashcardsInputSchema,\n  typeof GenerateFlashcardsOutputSchema\n>({\n  name: 'generateFlashcardsFlow',\n  inputSchema: GenerateFlashcardsInputSchema,\n  outputSchema: GenerateFlashcardsOutputSchema,\n}, async (input) => {\n  console.log('[generateFlashcardsFlow] Starting flow execution for PDF:', input.pdfDataUri.substring(0, 50) + \"...\"); // Log start\n\n  try {\n      console.log('[generateFlashcardsFlow] Calling AI prompt...');\n      const {output, usage} = await prompt(input);\n      console.log('[generateFlashcardsFlow] AI prompt call completed.');\n      console.log('[generateFlashcardsFlow] Usage:', usage);\n\n\n      // Validate the output structure\n      if (!output || !Array.isArray(output.flashcards)) {\n        console.error('[generateFlashcardsFlow] AI failed to return a valid response structure. Output received:', output);\n        throw new Error(\"AI failed to generate flashcards. Output was missing or invalid (expected { flashcards: [...] }).\");\n      }\n\n      // Validate individual flashcards (ensure both question and answer exist)\n      const validFlashcards = output.flashcards.filter(card =>\n          card &&\n          typeof card.question === 'string' && card.question.trim() !== '' &&\n          typeof card.answer === 'string' && card.answer.trim() !== ''\n      );\n      if (validFlashcards.length !== output.flashcards.length) {\n          const invalidCount = output.flashcards.length - validFlashcards.length;\n          console.warn(`[generateFlashcardsFlow] ${invalidCount} generated card(s) were invalid (missing question/answer) and filtered out. Original: ${output.flashcards.length}, Valid: ${validFlashcards.length}`);\n      }\n\n\n      console.log(`[generateFlashcardsFlow] Flashcards generation successful. Found ${validFlashcards.length} valid cards.`);\n      return { flashcards: validFlashcards }; // Return only the valid cards\n\n  } catch (error) {\n      console.error('[generateFlashcardsFlow] Error during prompt execution:', error);\n      // Check if the error is from the AI model itself (e.g., content filtering, API issues)\n      // This might require inspecting the error object structure provided by Genkit/GoogleAI\n      // if (error.isAiError) { ... }\n      throw new Error(`AI prompt failed: ${error instanceof Error ? error.message : String(error)}`); // Re-throw a more specific error\n  }\n});\n\n// IMPORTANT: Because this file uses 'use server', it CANNOT directly export the\n// result of ai.defineFlow. We export the wrapper function `generateFlashcardsFromPdf` instead.\n// The Genkit flow `generateFlashcardsFlow` is defined but only called internally by the wrapper.\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 492, "column": 0}, "map": {"version":3,"sources":["file:///Users/tanishqbedi/Documents/Projects/kageyama/lifeos/src/ai/flows/generate-notes.ts"],"sourcesContent":["'use server';\n/**\n * @fileOverview AI-powered note generation from PDF content.\n *\n * - generateNotesFromPdf - A function that generates study notes from a PDF data URI.\n * - GenerateNotesInput - The input type for the generateNotesFromPdf function.\n * - GenerateNotesOutput - The return type for the generateNotesFromPdf function.\n * - NoteData - The structured data type for generated notes.\n */\n\nimport {ai} from '@/ai/ai-instance';\nimport {z} from 'genkit';\nimport type { NoteData } from '@/types'; // Import the structured NoteData type\n\n// Define input schema (internal, not exported)\nconst GenerateNotesInputSchema = z.object({\n  pdfDataUri: z\n    .string()\n    .describe(\n      \"The content of the PDF file, as a data URI that must include a MIME type (application/pdf) and use Base64 encoding. Expected format: 'data:application/pdf;base64,<encoded_data>'.\"\n    ),\n   instructions: z\n    .string()\n    .optional()\n    .describe('Optional custom instructions for the note generation process (e.g., focus areas, desired format, specific tags/category).'),\n});\nexport type GenerateNotesInput = z.infer<typeof GenerateNotesInputSchema>; // Export the type\n\n// Define output schema to match NoteData structure (internal, not exported)\nconst GenerateNotesOutputSchema = z.object({\n  content: z.string().describe('The generated study notes in markdown format.'),\n  tags: z.array(z.string()).describe('Suggested relevant tags for the notes (e.g., [\"Physics\", \"Quantum Mechanics\", \"Chapter 3\"]). Generate 3-5 relevant tags.'),\n  category: z.string().describe('A suggested single primary category for the notes (e.g., \"Physics\", \"Lecture Summary\", \"Study Guide\").'),\n});\n// Output type aligns with the main part of NoteData, generatedAt is added later\nexport type GenerateNotesOutput = z.infer<typeof GenerateNotesOutputSchema>; // Export the type\n\n// Exported wrapper function returns the full NoteData structure\nexport async function generateNotesFromPdf(input: GenerateNotesInput): Promise<NoteData> {\n  // Validate that the data URI is for a PDF\n  if (!input.pdfDataUri || !input.pdfDataUri.startsWith('data:application/pdf;base64,')) {\n    throw new Error('Invalid input: pdfDataUri must be a base64 encoded PDF data URI starting with \"data:application/pdf;base64,\".');\n  }\n  console.log('[generateNotesFromPdf] Input validated. Calling generateNotesFlow...');\n  try {\n      const result = await generateNotesFlow(input);\n      console.log('[generateNotesFromPdf] Flow completed successfully.');\n      // Add timestamp and return the full NoteData object\n      const fullNoteData: NoteData = {\n        ...result,\n        generatedAt: Date.now(),\n      };\n      return fullNoteData;\n  } catch (error) {\n      console.error('[generateNotesFromPdf] Error calling generateNotesFlow:', error);\n      throw error; // Re-throw\n  }\n}\n\nconst prompt = ai.definePrompt({\n  name: 'generateNotesPrompt',\n  input: {\n    schema: GenerateNotesInputSchema\n  },\n  output: {\n    schema: GenerateNotesOutputSchema,\n    format: 'json', // Ensure JSON output\n  },\n  prompt: `You are an expert academic assistant specializing in summarizing and creating structured study notes from PDF documents.\n\n  Analyze the provided PDF document and generate:\n  1. Comprehensive yet concise study notes in **Markdown format**. Cover key topics, concepts, definitions, and important details. Structure the notes logically using headings, bullet points, etc.\n  2. An array of 3-5 relevant **tags** (keywords) that accurately represent the note's content.\n  3. A single, relevant primary **category** for the notes.\n\n  {{#if instructions}}\n  Follow these specific instructions for content, tags, and category: {{{instructions}}}\n  {{else}}\n  Generate general study notes covering the main points, suitable tags, and an appropriate category.\n  {{/if}}\n\n  PDF Content:\n  {{media url=pdfDataUri}}\n\n  Generate the notes, tags, and category now based on the PDF content and instructions. Respond ONLY with a JSON object containing 'content', 'tags', and 'category' fields. Do not include any introductory text or markdown formatting around the JSON.\n  `,\n  // Specify the model capable of processing PDFs (Gemini 1.5 Flash or Pro)\n  model: 'googleai/gemini-1.5-flash', // Or 'googleai/gemini-1.5-pro' if flash is insufficient\n});\n\n// Internal flow definition\nconst generateNotesFlow = ai.defineFlow<\n  typeof GenerateNotesInputSchema,\n  typeof GenerateNotesOutputSchema // Flow returns the AI output structure\n>({\n  name: 'generateNotesFlow',\n  inputSchema: GenerateNotesInputSchema,\n  outputSchema: GenerateNotesOutputSchema,\n}, async input => {\n  console.log('[generateNotesFlow] Starting flow execution for PDF:', input.pdfDataUri.substring(0, 50) + \"...\"); // Log start\n  const {output, usage} = await prompt(input);\n  console.log('[generateNotesFlow] AI prompt call completed. Usage:', usage);\n\n   if (!output || typeof output.content !== 'string' || !Array.isArray(output.tags) || typeof output.category !== 'string') {\n      console.error('[generateNotesFlow] AI failed to return a valid response structure. Output received:', output);\n      throw new Error(\"AI failed to generate notes, tags, or category in the expected format.\");\n   }\n\n   // Basic validation for tags and category\n   const validTags = output.tags.filter(tag => typeof tag === 'string' && tag.trim() !== '');\n   const validCategory = output.category.trim() || 'Uncategorized'; // Default category if empty\n\n   console.log(`[generateNotesFlow] Notes generation successful. Content length: ${output.content.length}, Tags: ${validTags.join(', ')}, Category: ${validCategory}`);\n   // Return the structured data as defined by GenerateNotesOutputSchema\n   return {\n     content: output.content,\n     tags: validTags,\n     category: validCategory,\n   };\n});\n"],"names":[],"mappings":";;;;;AACA;;;;;;;CAOC,GAED;AACA;AAAA;;;;;;AAGA,+CAA+C;AAC/C,MAAM,2BAA2B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACxC,YAAY,uIAAA,CAAA,IAAC,CACV,MAAM,GACN,QAAQ,CACP;IAEH,cAAc,uIAAA,CAAA,IAAC,CACb,MAAM,GACN,QAAQ,GACR,QAAQ,CAAC;AACd;AAGA,4EAA4E;AAC5E,MAAM,4BAA4B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACzC,SAAS,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC7B,MAAM,uIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,uIAAA,CAAA,IAAC,CAAC,MAAM,IAAI,QAAQ,CAAC;IACnC,UAAU,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAChC;AAKO,eAAe,uCAAkB,GAAlB,qBAAqB,KAAyB;IAClE,0CAA0C;IAC1C,IAAI,CAAC,MAAM,UAAU,IAAI,CAAC,MAAM,UAAU,CAAC,UAAU,CAAC,iCAAiC;QACrF,MAAM,IAAI,MAAM;IAClB;IACA,QAAQ,GAAG,CAAC;IACZ,IAAI;QACA,MAAM,SAAS,MAAM,kBAAkB;QACvC,QAAQ,GAAG,CAAC;QACZ,oDAAoD;QACpD,MAAM,eAAyB;YAC7B,GAAG,MAAM;YACT,aAAa,KAAK,GAAG;QACvB;QACA,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,2DAA2D;QACzE,MAAM,OAAO,WAAW;IAC5B;AACF;AAEA,MAAM,SAAS,2HAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QACL,QAAQ;IACV;IACA,QAAQ;QACN,QAAQ;QACR,QAAQ;IACV;IACA,QAAQ,CAAC;;;;;;;;;;;;;;;;;EAiBT,CAAC;IACD,yEAAyE;IACzE,OAAO;AACT;AAEA,2BAA2B;AAC3B,MAAM,oBAAoB,2HAAA,CAAA,KAAE,CAAC,UAAU,CAGrC;IACA,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GAAG,OAAM;IACP,QAAQ,GAAG,CAAC,wDAAwD,MAAM,UAAU,CAAC,SAAS,CAAC,GAAG,MAAM,QAAQ,YAAY;IAC5H,MAAM,EAAC,MAAM,EAAE,KAAK,EAAC,GAAG,MAAM,OAAO;IACrC,QAAQ,GAAG,CAAC,wDAAwD;IAEnE,IAAI,CAAC,UAAU,OAAO,OAAO,OAAO,KAAK,YAAY,CAAC,MAAM,OAAO,CAAC,OAAO,IAAI,KAAK,OAAO,OAAO,QAAQ,KAAK,UAAU;QACtH,QAAQ,KAAK,CAAC,wFAAwF;QACtG,MAAM,IAAI,MAAM;IACnB;IAEA,yCAAyC;IACzC,MAAM,YAAY,OAAO,IAAI,CAAC,MAAM,CAAC,CAAA,MAAO,OAAO,QAAQ,YAAY,IAAI,IAAI,OAAO;IACtF,MAAM,gBAAgB,OAAO,QAAQ,CAAC,IAAI,MAAM,iBAAiB,4BAA4B;IAE7F,QAAQ,GAAG,CAAC,CAAC,iEAAiE,EAAE,OAAO,OAAO,CAAC,MAAM,CAAC,QAAQ,EAAE,UAAU,IAAI,CAAC,MAAM,YAAY,EAAE,eAAe;IAClK,qEAAqE;IACrE,OAAO;QACL,SAAS,OAAO,OAAO;QACvB,MAAM;QACN,UAAU;IACZ;AACH;;;IAjFsB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 608, "column": 0}, "map": {"version":3,"sources":["file:///Users/tanishqbedi/Documents/Projects/kageyama/lifeos/src/ai/flows/answer-question.ts"],"sourcesContent":["'use server';\n\n/**\n * @fileOverview An AI assistant that answers user questions.\n *\n * - answerQuestion - A function that answers a question.\n * - AnswerQuestionInput - The input type for the answerQuestion function.\n * - AnswerQuestionOutput - The return type for the answerQuestion function.\n */\n\nimport {ai} from '@/ai/ai-instance';\nimport {z} from 'genkit';\n\n// Define input schema (internal, not exported)\nconst AnswerQuestionInputSchema = z.object({\n  question: z.string().describe('The question to answer.'),\n});\nexport type AnswerQuestionInput = z.infer<typeof AnswerQuestionInputSchema>; // Export the type\n\n// Define output schema (internal, not exported)\nconst AnswerQuestionOutputSchema = z.object({\n  answer: z.string().describe('The answer to the question.'),\n});\nexport type AnswerQuestionOutput = z.infer<typeof AnswerQuestionOutputSchema>; // Export the type\n\nexport async function answerQuestion(input: AnswerQuestionInput): Promise<AnswerQuestionOutput> {\n  return answerQuestionFlow(input);\n}\n\nconst answerQuestionPrompt = ai.definePrompt({\n  name: 'answerQuestionPrompt',\n  input: {\n    schema: AnswerQuestionInputSchema,\n  },\n  output: {\n    schema: AnswerQuestionOutputSchema,\n  },\n  prompt: `You are an AI assistant. Answer the following question: {{{question}}}`,\n});\n\nconst answerQuestionFlow = ai.defineFlow<\n  typeof AnswerQuestionInputSchema,\n  typeof AnswerQuestionOutputSchema\n>({\n  name: 'answerQuestionFlow',\n  inputSchema: AnswerQuestionInputSchema,\n  outputSchema: AnswerQuestionOutputSchema,\n}, async input => {\n  const {output} = await answerQuestionPrompt(input);\n  return output!;\n});\n\n"],"names":[],"mappings":";;;;;AAEA;;;;;;CAMC,GAED;AACA;AAAA;;;;;;AAEA,+CAA+C;AAC/C,MAAM,4BAA4B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACzC,UAAU,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAChC;AAGA,gDAAgD;AAChD,MAAM,6BAA6B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC1C,QAAQ,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAC9B;AAGO,eAAe,uCAAY,GAAZ,eAAe,KAA0B;IAC7D,OAAO,mBAAmB;AAC5B;AAEA,MAAM,uBAAuB,2HAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC3C,MAAM;IACN,OAAO;QACL,QAAQ;IACV;IACA,QAAQ;QACN,QAAQ;IACV;IACA,QAAQ,CAAC,sEAAsE,CAAC;AAClF;AAEA,MAAM,qBAAqB,2HAAA,CAAA,KAAE,CAAC,UAAU,CAGtC;IACA,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GAAG,OAAM;IACP,MAAM,EAAC,MAAM,EAAC,GAAG,MAAM,qBAAqB;IAC5C,OAAO;AACT;;;IAzBsB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 667, "column": 0}, "map": {"version":3,"sources":["file:///Users/tanishqbedi/Documents/Projects/kageyama/lifeos/src/ai/flows/generate-gemini-key.ts"],"sourcesContent":["\n'use server';\n\n/**\n * @fileOverview AI-powered Q&A assistant with Gemini key autogeneration (simulation).\n *\n * - generateGeminiKey - A function that handles the Gemini API key generation process (simulation).\n * - GenerateGeminiKeyInput - The input type for the generateGeminiKey function.\n * - GenerateGeminiKeyOutput - The return type for the generateGeminiKey function.\n */\n\nimport {ai} from '@/ai/ai-instance'; // Ensure this path is correct\nimport {z} from 'genkit';\n\n// Define input schema (internal, not exported)\nconst GenerateGeminiKeyInputSchema = z.object({\n  userDescription: z\n    .string()\n    .describe('Description of the user and their use case for the Gemini API key.'),\n});\nexport type GenerateGeminiKeyInput = z.infer<typeof GenerateGeminiKeyInputSchema>; // Export the type\n\n// Define output schema (internal, not exported)\nconst GenerateGeminiKeyOutputSchema = z.object({\n  geminiApiKey: z.string().describe('The \"generated\" (simulated) Gemini API key.'),\n  instructions: z.string().describe('Instructions on how to use a real Gemini API key, and a note about this being a simulation.'),\n});\nexport type GenerateGeminiKeyOutput = z.infer<typeof GenerateGeminiKeyOutputSchema>; // Export the type\n\nexport async function generateGeminiKey(input: GenerateGeminiKeyInput): Promise<GenerateGeminiKeyOutput> {\n  // No need to call a prompt for this simulation. We directly construct the output.\n  console.log('[generateGeminiKey] Simulating Gemini Key generation for user:', input.userDescription.substring(0, 50) + '...');\n  \n  // Generate a fake API key for demonstration\n  const fakeApiKey = `FAKE-AIzaSy${Math.random().toString(36).substring(2, 15)}${Math.random().toString(36).substring(2, 15)}`;\n  \n  const instructions = `\n**This is a SIMULATED API Key. It will NOT work with actual Google AI services.**\n\nTo use a real Gemini API key:\n1.  **Get a Real Key:** Visit the Google AI Studio (https://aistudio.google.com/app/apikey) to create an API key.\n2.  **Secure Your Key:** Keep your real API key secure! Do not share it publicly or commit it to code repositories.\n3.  **Environment Setup:** Store your real key in an environment variable (e.g., \\`GOOGLE_GENAI_API_KEY\\`) in your project's \\`.env\\` file.\n4.  **Usage:** Refer to the Gemini API documentation for specific usage instructions in your applications.\n5.  **Monitoring:** Monitor your API usage in the Google Cloud Console.\n`;\n\n  const output: GenerateGeminiKeyOutput = {\n    geminiApiKey: fakeApiKey,\n    instructions: instructions.trim(),\n  };\n  \n  console.log('[generateGeminiKey] Simulated key and instructions prepared.');\n  return output; // Directly return the simulated output\n}\n\n// The Genkit flow definition can be removed or commented out if not used,\n// as the exported function `generateGeminiKey` now handles the simulation directly.\n// If you intend to keep it for potential future integration with a real key generation service,\n// it would look something like this, but would require a tool or a model capable of this.\n\n/*\nconst prompt = ai.definePrompt({\n  name: 'generateGeminiKeyPrompt',\n  input: {\n    schema: GenerateGeminiKeyInputSchema,\n  },\n  output: {\n    schema: GenerateGeminiKeyOutputSchema,\n  },\n  prompt: \\`You are an AI assistant that can generate Gemini API keys for users.\n  Based on the user description, generate a Gemini API key and provide instructions on how to use it.\n  User Description: {{{userDescription}}}\n  \\`,\n  // This prompt would likely require a 'tool' to actually generate a key.\n});\n\nconst generateGeminiKeyFlow = ai.defineFlow<\n  typeof GenerateGeminiKeyInputSchema,\n  typeof GenerateGeminiKeyOutputSchema\n>({\n  name: 'generateGeminiKeyFlow',\n  inputSchema: GenerateGeminiKeyInputSchema,\n  outputSchema: GenerateGeminiKeyOutputSchema,\n}, async input => {\n  // In a real scenario, this would interact with a key generation service/tool\n  // For simulation, we're handling it in the exported function directly.\n  // const {output} = await prompt(input); // This would call the LLM\n  // return output!;\n  \n  // For this simulation, the flow would just call the direct logic.\n  // However, the exported function `generateGeminiKey` above bypasses this flow.\n  const fakeApiKey = \\`SIMULATED-KEY-\\${Date.now()}\\`;\n  const instructions = \"This is a simulated key. See Google AI Studio for real keys.\";\n  return { geminiApiKey: fakeApiKey, instructions };\n});\n*/\n"],"names":[],"mappings":";;;;;AAYA;AAAA;;;;;AAEA,+CAA+C;AAC/C,MAAM,+BAA+B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC5C,iBAAiB,uIAAA,CAAA,IAAC,CACf,MAAM,GACN,QAAQ,CAAC;AACd;AAGA,gDAAgD;AAChD,MAAM,gCAAgC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC7C,cAAc,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAClC,cAAc,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AACpC;AAGO,eAAe,uCAAe,GAAf,kBAAkB,KAA6B;IACnE,kFAAkF;IAClF,QAAQ,GAAG,CAAC,kEAAkE,MAAM,eAAe,CAAC,SAAS,CAAC,GAAG,MAAM;IAEvH,4CAA4C;IAC5C,MAAM,aAAa,CAAC,WAAW,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAG,MAAM,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAG,KAAK;IAE5H,MAAM,eAAe,CAAC;;;;;;;;;AASxB,CAAC;IAEC,MAAM,SAAkC;QACtC,cAAc;QACd,cAAc,aAAa,IAAI;IACjC;IAEA,QAAQ,GAAG,CAAC;IACZ,OAAO,QAAQ,uCAAuC;AACxD,EAEA,0EAA0E;CAC1E,oFAAoF;CACpF,gGAAgG;CAChG,0FAA0F;CAE1F;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA;;;IAnEsB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 759, "column": 0}, "map": {"version":3,"sources":["file:///Users/tanishqbedi/Documents/Projects/kageyama/lifeos/src/ai/flows/summarize-content-flow.ts"],"sourcesContent":["'use server';\n/**\n * @fileOverview AI-powered content summarization.\n *\n * - summarizeContent - Function to generate a summary from text content.\n * - SummarizeContentInput - Input type for the summarizeContent function.\n * - SummarizeContentOutput - Return type for the summarizeContent function (aligns with NoteData structure).\n */\n\nimport { ai } from '@/ai/ai-instance';\nimport { z } from 'genkit';\nimport type { NoteData } from '@/types'; // Import NoteData for output alignment\n\n// --- Input Schema ---\nconst SummarizeContentInputSchema = z.object({\n  textContent: z.string().min(50).describe('The text content to be summarized (at least 50 characters).'),\n  sourceUrl: z.string().url().optional().describe('Optional source URL of the content for context.'),\n  instructions: z.string().optional().describe('Optional custom instructions for the summarization process (e.g., desired length, key focus areas, target audience).'),\n});\nexport type SummarizeContentInput = z.infer<typeof SummarizeContentInputSchema>;\n\n// --- Output Schema (Matches NoteData structure for consistency) ---\nconst SummarizeContentOutputSchema = z.object({\n  content: z.string().describe('The generated summary in markdown format.'),\n  tags: z.array(z.string()).describe('Suggested relevant tags for the summary (e.g., [\"AI\", \"Summarization\", \"Article\"]). Generate 3-5 relevant tags.'),\n  category: z.string().describe('A suggested single primary category for the summary (e.g., \"Article Summary\", \"Research Notes\").'),\n  // generatedAt will be added by the calling function\n});\n// Output type aligns with the main part of NoteData\nexport type SummarizeContentOutput = z.infer<typeof SummarizeContentOutputSchema>;\n\n// --- Exported Wrapper Function (returns full NoteData) ---\nexport async function summarizeContent(input: SummarizeContentInput): Promise<NoteData> {\n  console.log('[summarizeContent] Request received.');\n  // Basic validation\n  if (!input.textContent || input.textContent.length < 50) {\n    throw new Error('Text content must be at least 50 characters long.');\n  }\n\n  try {\n    const result = await summarizeContentFlow(input);\n    console.log('[summarizeContent] Flow completed successfully.');\n    // Add timestamp and return the full NoteData object\n    const fullNoteData: NoteData = {\n      ...result,\n      generatedAt: Date.now(),\n    };\n    return fullNoteData;\n  } catch (error) {\n    console.error('[summarizeContent] Error calling flow:', error);\n    throw error; // Re-throw for the calling component\n  }\n}\n\n// --- AI Prompt Definition ---\nconst prompt = ai.definePrompt({\n  name: 'summarizeContentPrompt',\n  input: {\n    schema: SummarizeContentInputSchema,\n  },\n  output: {\n    schema: SummarizeContentOutputSchema,\n    format: 'json', // Ensure structured JSON output\n  },\n  prompt: `You are an expert summarization AI. Analyze the provided text content and generate:\n1. A concise and accurate summary in **Markdown format**. Capture the main points and key information.\n2. An array of 3-5 relevant **tags** (keywords) for the summary.\n3. A single, relevant primary **category** for the summary (e.g., \"Article Summary\", \"Meeting Notes\", \"Research Paper\").\n\n{{#if sourceUrl}}\nSource URL (for context): {{{sourceUrl}}}\n{{/if}}\n\n{{#if instructions}}\nFollow these specific instructions for the summary, tags, and category: {{{instructions}}}\n{{else}}\nGenerate a general summary covering the main points, appropriate tags, and a suitable category. Adjust summary length based on the input text length - be concise but comprehensive.\n{{/if}}\n\nText Content to Summarize:\n{{{textContent}}}\n\nGenerate the summary, tags, and category now. Respond ONLY with a JSON object containing 'content', 'tags', and 'category' fields. Do not include any introductory text or markdown formatting around the JSON.\n  `,\n  // Use a model capable of potentially longer context if needed\n  // model: 'googleai/gemini-1.5-flash',\n});\n\n// --- Genkit Flow Definition ---\nconst summarizeContentFlow = ai.defineFlow<\n  typeof SummarizeContentInputSchema,\n  typeof SummarizeContentOutputSchema // Flow returns the AI output structure\n>({\n  name: 'summarizeContentFlow',\n  inputSchema: SummarizeContentInputSchema,\n  outputSchema: SummarizeContentOutputSchema,\n}, async (input) => {\n  console.log('[summarizeContentFlow] Starting flow execution...');\n  try {\n    const { output, usage } = await prompt(input);\n    console.log('[summarizeContentFlow] AI prompt call completed. Usage:', usage);\n\n    if (!output || typeof output.content !== 'string' || !Array.isArray(output.tags) || typeof output.category !== 'string') {\n      console.error('[summarizeContentFlow] AI failed to return a valid response structure. Output:', output);\n      throw new Error(\"AI failed to generate summary, tags, or category in the expected format.\");\n    }\n\n    // Basic validation for tags and category\n    const validTags = output.tags.filter(tag => typeof tag === 'string' && tag.trim() !== '');\n    const validCategory = output.category.trim() || 'Summary'; // Default category if empty\n\n    console.log(`[summarizeContentFlow] Summary generation successful. Content length: ${output.content.length}, Tags: ${validTags.join(', ')}, Category: ${validCategory}`);\n    // Return the structured data as defined by SummarizeContentOutputSchema\n    return {\n      content: output.content,\n      tags: validTags,\n      category: validCategory,\n    };\n\n  } catch (error) {\n    console.error('[summarizeContentFlow] Error during prompt execution:', error);\n    throw new Error(`AI prompt failed: ${error instanceof Error ? error.message : String(error)}`);\n  }\n});\n"],"names":[],"mappings":";;;;;AACA;;;;;;CAMC,GAED;AACA;AAAA;;;;;;AAGA,uBAAuB;AACvB,MAAM,8BAA8B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC3C,aAAa,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,GAAG,CAAC,IAAI,QAAQ,CAAC;IACzC,WAAW,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,GAAG,GAAG,QAAQ,GAAG,QAAQ,CAAC;IAChD,cAAc,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;AAC/C;AAGA,qEAAqE;AACrE,MAAM,+BAA+B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC5C,SAAS,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC7B,MAAM,uIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,uIAAA,CAAA,IAAC,CAAC,MAAM,IAAI,QAAQ,CAAC;IACnC,UAAU,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAEhC;AAKO,eAAe,uCAAc,GAAd,iBAAiB,KAA4B;IACjE,QAAQ,GAAG,CAAC;IACZ,mBAAmB;IACnB,IAAI,CAAC,MAAM,WAAW,IAAI,MAAM,WAAW,CAAC,MAAM,GAAG,IAAI;QACvD,MAAM,IAAI,MAAM;IAClB;IAEA,IAAI;QACF,MAAM,SAAS,MAAM,qBAAqB;QAC1C,QAAQ,GAAG,CAAC;QACZ,oDAAoD;QACpD,MAAM,eAAyB;YAC7B,GAAG,MAAM;YACT,aAAa,KAAK,GAAG;QACvB;QACA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,0CAA0C;QACxD,MAAM,OAAO,qCAAqC;IACpD;AACF;AAEA,+BAA+B;AAC/B,MAAM,SAAS,2HAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QACL,QAAQ;IACV;IACA,QAAQ;QACN,QAAQ;QACR,QAAQ;IACV;IACA,QAAQ,CAAC;;;;;;;;;;;;;;;;;;;EAmBT,CAAC;AAGH;AAEA,iCAAiC;AACjC,MAAM,uBAAuB,2HAAA,CAAA,KAAE,CAAC,UAAU,CAGxC;IACA,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GAAG,OAAO;IACR,QAAQ,GAAG,CAAC;IACZ,IAAI;QACF,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,OAAO;QACvC,QAAQ,GAAG,CAAC,2DAA2D;QAEvE,IAAI,CAAC,UAAU,OAAO,OAAO,OAAO,KAAK,YAAY,CAAC,MAAM,OAAO,CAAC,OAAO,IAAI,KAAK,OAAO,OAAO,QAAQ,KAAK,UAAU;YACvH,QAAQ,KAAK,CAAC,kFAAkF;YAChG,MAAM,IAAI,MAAM;QAClB;QAEA,yCAAyC;QACzC,MAAM,YAAY,OAAO,IAAI,CAAC,MAAM,CAAC,CAAA,MAAO,OAAO,QAAQ,YAAY,IAAI,IAAI,OAAO;QACtF,MAAM,gBAAgB,OAAO,QAAQ,CAAC,IAAI,MAAM,WAAW,4BAA4B;QAEvF,QAAQ,GAAG,CAAC,CAAC,sEAAsE,EAAE,OAAO,OAAO,CAAC,MAAM,CAAC,QAAQ,EAAE,UAAU,IAAI,CAAC,MAAM,YAAY,EAAE,eAAe;QACvK,wEAAwE;QACxE,OAAO;YACL,SAAS,OAAO,OAAO;YACvB,MAAM;YACN,UAAU;QACZ;IAEF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,yDAAyD;QACvE,MAAM,IAAI,MAAM,CAAC,kBAAkB,EAAE,iBAAiB,QAAQ,MAAM,OAAO,GAAG,OAAO,QAAQ;IAC/F;AACF;;;IA3FsB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 881, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 957, "column": 0}, "map": {"version":3,"sources":["file:///Users/tanishqbedi/Documents/Projects/kageyama/lifeos/src/app/flashcards/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/flashcards/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/flashcards/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAA+R,GAC5T,6DACA","debugId":null}},
    {"offset": {"line": 971, "column": 0}, "map": {"version":3,"sources":["file:///Users/tanishqbedi/Documents/Projects/kageyama/lifeos/src/app/flashcards/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/flashcards/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/flashcards/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAA2Q,GACxS,yCACA","debugId":null}},
    {"offset": {"line": 985, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}