{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/lib/session.ts"],"sourcesContent":["// src/lib/session.ts\nimport { SignJWT, jwtVerify } from 'jose';\nimport { cookies } from 'next/headers';\nimport { NextResponse, type NextRequest } from 'next/server'; // Corrected import for NextResponse\n\nconst JWT_SECRET_KEY = process.env.JWT_SECRET;\nconst JWT_COOKIE_NAME = 'lifeos_session_token';\nconst JWT_EXPIRATION_TIME = '30d'; // Session expiration time\n\nif (!JWT_SECRET_KEY) {\n  throw new Error('Please define the JWT_SECRET environment variable inside .env');\n}\n\nconst secret = new TextEncoder().encode(JWT_SECRET_KEY);\n\ninterface UserJWTPayload {\n  userId: string;\n  email: string;\n  // Add other non-sensitive user data you might want in the JWT\n  exp?: number; // Standard JWT expiration claim\n}\n\nexport async function encrypt(payload: UserJWTPayload): Promise<string> {\n  return await new SignJWT(payload)\n    .setProtectedHeader({ alg: 'HS256' })\n    .setIssuedAt()\n    .setExpirationTime(JWT_EXPIRATION_TIME)\n    .sign(secret);\n}\n\nexport async function decrypt(token: string): Promise<UserJWTPayload | null> {\n  try {\n    const { payload } = await jwtVerify<UserJWTPayload>(token, secret, {\n      algorithms: ['HS256'],\n    });\n    return payload;\n  } catch (error) {\n    console.error('JWT verification failed:', error);\n    return null;\n  }\n}\n\nexport async function createSession(userId: string, email: string) {\n  const expires = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days\n  const sessionToken = await encrypt({ userId, email, exp: expires.getTime() / 1000 });\n\n  cookies().set(JWT_COOKIE_NAME, sessionToken, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === 'production',\n    expires: expires,\n    sameSite: 'lax',\n    path: '/',\n  });\n  console.log(`Session created for user ${userId}, cookie set.`);\n}\n\nexport async function getSessionFromCookie(): Promise<UserJWTPayload | null> {\n  const sessionCookie = cookies().get(JWT_COOKIE_NAME)?.value;\n  if (!sessionCookie) {\n    return null;\n  }\n  return await decrypt(sessionCookie);\n}\n\nexport async function deleteSession() {\n  cookies().set(JWT_COOKIE_NAME, '', { expires: new Date(0), path: '/' });\n  console.log('Session cookie deleted.');\n}\n\n// This function is used by middleware to update the session cookie's expiration.\nexport async function updateSessionCookie(request: NextRequest): Promise<NextResponse | undefined> {\n  const sessionCookie = request.cookies.get(JWT_COOKIE_NAME)?.value;\n  let response = NextResponse.next({ request: { headers: request.headers } });\n\n  if (!sessionCookie) {\n    return response; // No session to update\n  }\n\n  const parsed = await decrypt(sessionCookie);\n  if (parsed?.userId && parsed.email) {\n    // Re-encrypt and set the cookie to refresh its expiration time\n    const expires = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days\n    const newSessionToken = await encrypt({ userId: parsed.userId, email: parsed.email, exp: expires.getTime() / 1000 });\n    \n    response.cookies.set(JWT_COOKIE_NAME, newSessionToken, {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      expires: expires,\n      sameSite: 'lax',\n      path: '/',\n    });\n    console.log('Session cookie updated for user', parsed.userId);\n  } else {\n    // Invalid session, clear it\n    response.cookies.set(JWT_COOKIE_NAME, '', { expires: new Date(0), path: '/' });\n  }\n  return response;\n}\n\n"],"names":[],"mappings":"AAAA,qBAAqB;;;;;;;;;AACrB;AAAA;AACA;AAAA;AACA,iUAA8D,oCAAoC;AAAlG;;;;AAEA,MAAM,iBAAiB,QAAQ,GAAG,CAAC,UAAU;AAC7C,MAAM,kBAAkB;AACxB,MAAM,sBAAsB,OAAO,0BAA0B;AAE7D,IAAI,CAAC,gBAAgB;IACnB,MAAM,IAAI,MAAM;AAClB;AAEA,MAAM,SAAS,IAAI,cAAc,MAAM,CAAC;AASjC,eAAe,QAAQ,OAAuB;IACnD,OAAO,MAAM,IAAI,8JAAA,CAAA,UAAO,CAAC,SACtB,kBAAkB,CAAC;QAAE,KAAK;IAAQ,GAClC,WAAW,GACX,iBAAiB,CAAC,qBAClB,IAAI,CAAC;AACV;AAEO,eAAe,QAAQ,KAAa;IACzC,IAAI;QACF,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,CAAA,GAAA,gKAAA,CAAA,YAAS,AAAD,EAAkB,OAAO,QAAQ;YACjE,YAAY;gBAAC;aAAQ;QACvB;QACA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO;IACT;AACF;AAEO,eAAe,cAAc,MAAc,EAAE,KAAa;IAC/D,MAAM,UAAU,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,KAAK,KAAK,KAAK,OAAO,UAAU;IAC3E,MAAM,eAAe,MAAM,QAAQ;QAAE;QAAQ;QAAO,KAAK,QAAQ,OAAO,KAAK;IAAK;IAElF,CAAA,GAAA,2KAAA,CAAA,UAAO,AAAD,IAAI,GAAG,CAAC,iBAAiB,cAAc;QAC3C,UAAU;QACV,QAAQ,oDAAyB;QACjC,SAAS;QACT,UAAU;QACV,MAAM;IACR;IACA,QAAQ,GAAG,CAAC,CAAC,yBAAyB,EAAE,OAAO,aAAa,CAAC;AAC/D;AAEO,eAAe;IACpB,MAAM,gBAAgB,CAAA,GAAA,2KAAA,CAAA,UAAO,AAAD,IAAI,GAAG,CAAC,kBAAkB;IACtD,IAAI,CAAC,eAAe;QAClB,OAAO;IACT;IACA,OAAO,MAAM,QAAQ;AACvB;AAEO,eAAe;IACpB,CAAA,GAAA,2KAAA,CAAA,UAAO,AAAD,IAAI,GAAG,CAAC,iBAAiB,IAAI;QAAE,SAAS,IAAI,KAAK;QAAI,MAAM;IAAI;IACrE,QAAQ,GAAG,CAAC;AACd;AAGO,eAAe,oBAAoB,OAAoB;IAC5D,MAAM,gBAAgB,QAAQ,OAAO,CAAC,GAAG,CAAC,kBAAkB;IAC5D,IAAI,WAAW,6LAAA,CAAA,eAAY,CAAC,IAAI,CAAC;QAAE,SAAS;YAAE,SAAS,QAAQ,OAAO;QAAC;IAAE;IAEzE,IAAI,CAAC,eAAe;QAClB,OAAO,UAAU,uBAAuB;IAC1C;IAEA,MAAM,SAAS,MAAM,QAAQ;IAC7B,IAAI,QAAQ,UAAU,OAAO,KAAK,EAAE;QAClC,+DAA+D;QAC/D,MAAM,UAAU,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,KAAK,KAAK,KAAK,OAAO,UAAU;QAC3E,MAAM,kBAAkB,MAAM,QAAQ;YAAE,QAAQ,OAAO,MAAM;YAAE,OAAO,OAAO,KAAK;YAAE,KAAK,QAAQ,OAAO,KAAK;QAAK;QAElH,SAAS,OAAO,CAAC,GAAG,CAAC,iBAAiB,iBAAiB;YACrD,UAAU;YACV,QAAQ,oDAAyB;YACjC,SAAS;YACT,UAAU;YACV,MAAM;QACR;QACA,QAAQ,GAAG,CAAC,mCAAmC,OAAO,MAAM;IAC9D,OAAO;QACL,4BAA4B;QAC5B,SAAS,OAAO,CAAC,GAAG,CAAC,iBAAiB,IAAI;YAAE,SAAS,IAAI,KAAK;YAAI,MAAM;QAAI;IAC9E;IACA,OAAO;AACT"}},
    {"offset": {"line": 138, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/middleware.ts"],"sourcesContent":["\nimport { NextResponse } from 'next/server';\nimport type { NextRequest } from 'next/server';\nimport { getSessionFromCookie, updateSessionCookie } from '@/lib/session'; // Use JWT session logic\n\nconst publicRoutes = ['/login', '/signup'];\n// API routes that should not be protected by default or have their own auth\nconst apiAuthRoutes = ['/api/auth/login', '/api/auth/signup', '/api/auth/session'];\n\nexport async function middleware(request: NextRequest) {\n  const pathname = request.nextUrl.pathname;\n\n  // Allow API auth routes to pass through without session checks by middleware\n  if (apiAuthRoutes.some(route => pathname.startsWith(route))) {\n    return NextResponse.next();\n  }\n\n  // Check if the current route is public\n  const isPublicRoute = publicRoutes.some(route => pathname.startsWith(route));\n  const session = await getSessionFromCookie(); // Reads and decrypts JWT from cookie\n\n  if (session?.userId && isPublicRoute) {\n    // If session exists and trying to access a public route (like login), redirect to dashboard\n    console.log(`Middleware: User with session on public route ${pathname}, redirecting to /`);\n    return NextResponse.redirect(new URL('/', request.url));\n  }\n\n  if (!session?.userId && !isPublicRoute) {\n    // If no session and not a public route, redirect to login\n    // Avoid redirect loops for API routes that might be called by client before full auth check\n    if (pathname.startsWith('/api/')) {\n        // For non-auth API routes, if no session, return 401\n        // This prevents redirecting API calls to the login page HTML\n        console.log(`Middleware: No session for protected API route ${pathname}, returning 401`);\n        return NextResponse.json({ message: 'Authentication required' }, { status: 401 });\n    }\n    console.log(`Middleware: No session for protected route ${pathname}, redirecting to /login`);\n    return NextResponse.redirect(new URL('/login', request.url));\n  }\n\n  // If session exists and it's not a public route, try to update/refresh the session cookie\n  // The updateSessionCookie function will return a response with the updated cookie or undefined\n  if (session?.userId && !isPublicRoute) {\n    console.log(`Middleware: User with session on protected route ${pathname}, updating cookie.`);\n    return await updateSessionCookie(request); // updateSessionCookie now returns a response\n  }\n\n  // Allow the request to proceed if none of the above conditions are met\n  return NextResponse.next();\n}\n\nexport const config = {\n  matcher: [\n    // Match all routes except for static files, _next paths, and specific public assets like favicon.ico\n    '/((?!_next/static|_next/image|favicon.ico).*)',\n  ],\n};\n\n"],"names":[],"mappings":";;;;AACA;AAAA;AAEA,4NAA2E,wBAAwB;;;AAEnG,MAAM,eAAe;IAAC;IAAU;CAAU;AAC1C,4EAA4E;AAC5E,MAAM,gBAAgB;IAAC;IAAmB;IAAoB;CAAoB;AAE3E,eAAe,WAAW,OAAoB;IACnD,MAAM,WAAW,QAAQ,OAAO,CAAC,QAAQ;IAEzC,6EAA6E;IAC7E,IAAI,cAAc,IAAI,CAAC,CAAA,QAAS,SAAS,UAAU,CAAC,SAAS;QAC3D,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI;IAC1B;IAEA,uCAAuC;IACvC,MAAM,gBAAgB,aAAa,IAAI,CAAC,CAAA,QAAS,SAAS,UAAU,CAAC;IACrE,MAAM,UAAU,MAAM,CAAA,GAAA,6HAAA,CAAA,uBAAoB,AAAD,KAAK,qCAAqC;IAEnF,IAAI,SAAS,UAAU,eAAe;QACpC,4FAA4F;QAC5F,QAAQ,GAAG,CAAC,CAAC,8CAA8C,EAAE,SAAS,kBAAkB,CAAC;QACzF,OAAO,6LAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,KAAK,QAAQ,GAAG;IACvD;IAEA,IAAI,CAAC,SAAS,UAAU,CAAC,eAAe;QACtC,0DAA0D;QAC1D,4FAA4F;QAC5F,IAAI,SAAS,UAAU,CAAC,UAAU;YAC9B,qDAAqD;YACrD,6DAA6D;YAC7D,QAAQ,GAAG,CAAC,CAAC,+CAA+C,EAAE,SAAS,eAAe,CAAC;YACvF,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;YAA0B,GAAG;gBAAE,QAAQ;YAAI;QACnF;QACA,QAAQ,GAAG,CAAC,CAAC,2CAA2C,EAAE,SAAS,uBAAuB,CAAC;QAC3F,OAAO,6LAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,UAAU,QAAQ,GAAG;IAC5D;IAEA,0FAA0F;IAC1F,+FAA+F;IAC/F,IAAI,SAAS,UAAU,CAAC,eAAe;QACrC,QAAQ,GAAG,CAAC,CAAC,iDAAiD,EAAE,SAAS,kBAAkB,CAAC;QAC5F,OAAO,MAAM,CAAA,GAAA,6HAAA,CAAA,sBAAmB,AAAD,EAAE,UAAU,6CAA6C;IAC1F;IAEA,uEAAuE;IACvE,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI;AAC1B;AAEO,MAAM,SAAS;IACpB,SAAS;QACP,qGAAqG;QACrG;KACD;AACH"}}]
}