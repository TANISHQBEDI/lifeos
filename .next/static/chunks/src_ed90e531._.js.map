{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/tanishqbedi/Documents/Projects/kageyama/lifeos/src/hooks/use-mobile.tsx"],"sourcesContent":["import * as React from \"react\"\n\nconst MOBILE_BREAKPOINT = 768\n\nexport function useIsMobile() {\n  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)\n\n  React.useEffect(() => {\n    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)\n    const onChange = () => {\n      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\n    }\n    mql.addEventListener(\"change\", onChange)\n    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\n    return () => mql.removeEventListener(\"change\", onChange)\n  }, [])\n\n  return !!isMobile\n}\n"],"names":[],"mappings":";;;AAAA;;;AAEA,MAAM,oBAAoB;AAEnB,SAAS;;IACd,MAAM,CAAC,UAAU,YAAY,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAc,AAAD,EAAuB;IAEpE,CAAA,GAAA,6JAAA,CAAA,YAAe,AAAD;iCAAE;YACd,MAAM,MAAM,OAAO,UAAU,CAAC,CAAC,YAAY,EAAE,oBAAoB,EAAE,GAAG,CAAC;YACvE,MAAM;kDAAW;oBACf,YAAY,OAAO,UAAU,GAAG;gBAClC;;YACA,IAAI,gBAAgB,CAAC,UAAU;YAC/B,YAAY,OAAO,UAAU,GAAG;YAChC;yCAAO,IAAM,IAAI,mBAAmB,CAAC,UAAU;;QACjD;gCAAG,EAAE;IAEL,OAAO,CAAC,CAAC;AACX;GAdgB","debugId":null}},
    {"offset": {"line": 44, "column": 0}, "map": {"version":3,"sources":["file:///Users/tanishqbedi/Documents/Projects/kageyama/lifeos/src/hooks/use-toast.ts"],"sourcesContent":["\n\"use client\"\n\n// Inspired by react-hot-toast library\nimport * as React from \"react\"\n\nimport type {\n  ToastActionElement,\n  ToastProps,\n} from \"@/components/ui/toast\"\n\nconst TOAST_LIMIT = 1\nconst TOAST_REMOVE_DELAY = 5000 // Reduced delay for quicker removal\n\ntype ToasterToast = ToastProps & {\n  id: string\n  title?: React.ReactNode\n  description?: React.ReactNode\n  action?: ToastActionElement\n}\n\nconst actionTypes = {\n  ADD_TOAST: \"ADD_TOAST\",\n  UPDATE_TOAST: \"UPDATE_TOAST\",\n  DISMISS_TOAST: \"DISMISS_TOAST\",\n  REMOVE_TOAST: \"REMOVE_TOAST\",\n} as const\n\nlet count = 0\n\nfunction genId() {\n  count = (count + 1) % Number.MAX_SAFE_INTEGER\n  return count.toString()\n}\n\ntype ActionType = typeof actionTypes\n\ntype Action =\n  | {\n      type: ActionType[\"ADD_TOAST\"]\n      toast: ToasterToast\n    }\n  | {\n      type: ActionType[\"UPDATE_TOAST\"]\n      toast: Partial<ToasterToast>\n    }\n  | {\n      type: ActionType[\"DISMISS_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n  | {\n      type: ActionType[\"REMOVE_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n\ninterface State {\n  toasts: ToasterToast[]\n}\n\nconst toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()\n\nconst addToRemoveQueue = (toastId: string) => {\n  if (toastTimeouts.has(toastId)) {\n    return\n  }\n\n  const timeout = setTimeout(() => {\n    toastTimeouts.delete(toastId)\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define -- Stable dispatch reference\n    dispatch({\n      type: \"REMOVE_TOAST\",\n      toastId: toastId,\n    })\n  }, TOAST_REMOVE_DELAY)\n\n  toastTimeouts.set(toastId, timeout)\n}\n\n// Make reducer pure function\nconst reducer = (state: State, action: Action): State => {\n  switch (action.type) {\n    case \"ADD_TOAST\":\n      return {\n        ...state,\n        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),\n      }\n\n    case \"UPDATE_TOAST\":\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === action.toast.id ? { ...t, ...action.toast } : t\n        ),\n      }\n\n    case \"DISMISS_TOAST\": {\n      const { toastId } = action\n      // Side effect moved outside of reducer\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === toastId || toastId === undefined\n            ? {\n                ...t,\n                open: false,\n              }\n            : t\n        ),\n      }\n    }\n    case \"REMOVE_TOAST\":\n      if (action.toastId === undefined) {\n        return {\n          ...state,\n          toasts: [],\n        }\n      }\n      return {\n        ...state,\n        toasts: state.toasts.filter((t) => t.id !== action.toastId),\n      }\n  }\n}\n\nconst listeners: Array<(state: State) => void> = []\n\nlet memoryState: State = { toasts: [] }\n\n// Stable dispatch function reference\nconst dispatch = (action: Action) => {\n    // Handle side effects separately for DISMISS_TOAST\n    if (action.type === \"DISMISS_TOAST\") {\n        const { toastId } = action;\n        if (toastId) {\n            addToRemoveQueue(toastId);\n        } else {\n            memoryState.toasts.forEach((toast) => {\n                addToRemoveQueue(toast.id);\n            });\n        }\n    }\n\n    memoryState = reducer(memoryState, action);\n    listeners.forEach((listener) => {\n        listener(memoryState);\n    });\n};\n\n\ntype Toast = Omit<ToasterToast, \"id\">\n\nfunction toast({ ...props }: Toast) {\n  const id = genId()\n\n  const update = (props: ToasterToast) =>\n    dispatch({\n      type: \"UPDATE_TOAST\",\n      toast: { ...props, id },\n    })\n  const dismiss = () => dispatch({ type: \"DISMISS_TOAST\", toastId: id })\n\n  dispatch({\n    type: \"ADD_TOAST\",\n    toast: {\n      ...props,\n      id,\n      open: true,\n      onOpenChange: (open) => {\n        if (!open) dismiss()\n      },\n    },\n  })\n\n  return {\n    id: id,\n    dismiss,\n    update,\n  }\n}\n\nfunction useToast() {\n  const [state, setState] = React.useState<State>(memoryState)\n\n  React.useEffect(() => {\n    listeners.push(setState)\n    return () => {\n      const index = listeners.indexOf(setState)\n      if (index > -1) {\n        listeners.splice(index, 1)\n      }\n    }\n  }, [state]) // Dependency should technically be empty, but keeping `state` might be safer depending on exact React behavior nuances\n\n   // Memoize dismiss function\n   const dismiss = React.useCallback((toastId?: string) => {\n       dispatch({ type: \"DISMISS_TOAST\", toastId });\n   }, []);\n\n\n  return {\n    ...state,\n    toast, // toast function itself is stable\n    dismiss, // Use memoized dismiss\n  }\n}\n\nexport { useToast, toast }\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 223, "column": 0}, "map": {"version":3,"sources":["file:///Users/tanishqbedi/Documents/Projects/kageyama/lifeos/src/hooks/use-auth.tsx"],"sourcesContent":["// src/hooks/use-auth.tsx\n'use client';\n\nimport React, { createContext, useContext, useState, useEffect, ReactNode, useMemo, useCallback } from 'react';\nimport { Loader2 } from 'lucide-react';\nimport { useRouter, usePathname } from 'next/navigation';\nimport { useToast } from './use-toast';\n\n// Admin email from environment (used by server-side logic, not directly by this client hook for isAdmin determination)\nconst ADMIN_EMAIL_FROM_ENV = process.env.ADMIN_EMAIL || 'fowlstar1@gmail.com'; // Fallback for clarity, server uses its own .env\n\ninterface SessionUser {\n  id: string;\n  email: string;\n}\n\ninterface AuthContextType {\n  user: SessionUser | null;\n  userId: string | null;\n  loading: boolean;\n  isAdmin: boolean;\n  signIn: (email: string, password: string) => Promise<{ success: boolean; message: string; user?: SessionUser }>;\n  signUp: (email: string, password: string) => Promise<{ success: boolean; message: string; user?: SessionUser }>;\n  signOut: () => Promise<void>;\n  getAllUsers?: () => Promise<{ id: string; email: string, createdAt: string }[] | null>;\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\nexport const AuthProvider = ({ children }: { children: ReactNode }) => {\n  const [user, setUser] = useState<SessionUser | null>(null);\n  const [userId, setUserId] = useState<string | null>(null);\n  const [loading, setLoading] = useState(true); // Start as true for initial session check\n  const router = useRouter();\n  const pathname = usePathname();\n  const { toast } = useToast();\n\n  const checkSession = useCallback(async () => {\n    console.log('AuthProvider: Checking session...');\n    // setLoading(true) is usually set before this call by initial state or previous action\n    try {\n      const response = await fetch('/api/auth/session');\n      const data = await response.json();\n      console.log('AuthProvider: Session check response status:', response.status, 'Data:', data);\n\n      if (response.ok && data.user) {\n        console.log('AuthProvider: Session valid, user found:', data.user);\n        setUser(data.user);\n        setUserId(data.user.id);\n      } else {\n        console.log('AuthProvider: No active session or error during session check.');\n        setUser(null);\n        setUserId(null);\n        // Only redirect if not already on a public page and not loading auth state\n        // and not an API route\n        if (!loading && !['/login', '/signup'].includes(pathname) && !pathname.startsWith('/api')) {\n          console.log('AuthProvider: No session, not on public/API route, redirecting to /login');\n          router.push('/login');\n        }\n      }\n    } catch (error) {\n      console.error(\"AuthProvider: Error checking session:\", error);\n      setUser(null);\n      setUserId(null);\n       if (!loading && !['/login', '/signup'].includes(pathname) && !pathname.startsWith('/api')) {\n          console.log('AuthProvider: Error during session check, not on public/API route, redirecting to /login');\n          router.push('/login');\n      }\n    } finally {\n      setLoading(false);\n      console.log('AuthProvider: Session check complete, loading set to false.');\n    }\n  }, [pathname, router, loading]); // Added loading\n\n  useEffect(() => {\n    checkSession();\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []); // checkSession is memoized and doesn't need to be in deps if its own deps are stable\n\n  // isAdmin is determined by comparing the authenticated user's email with the ADMIN_EMAIL_FROM_ENV.\n  // This ADMIN_EMAIL_FROM_ENV should ideally match what the server uses (process.env.ADMIN_EMAIL).\n  const isAdmin = useMemo(() => !!user && user.email.toLowerCase() === ADMIN_EMAIL_FROM_ENV.toLowerCase(), [user]);\n\n  const handleApiAuth = async (endpoint: string, body: any): Promise<{ success: boolean; message: string; user?: SessionUser }> => {\n    console.log(`AuthProvider: Attempting API auth at ${endpoint} for email:`, body.email);\n    setLoading(true);\n    let responseText = ''; // Variable to store raw response text\n    try {\n      const response = await fetch(endpoint, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(body),\n      });\n      \n      // Try to get text first for better error logging if JSON parsing fails\n      responseText = await response.text(); \n      let data;\n\n      try {\n        data = JSON.parse(responseText);\n      } catch (parseError) {\n        console.error(`AuthProvider: Failed to parse JSON response from ${endpoint}. Status: ${response.status}. Response text: ${responseText}`, parseError);\n        toast({ title: \"Error\", description: \"Received an invalid response from the server.\", variant: \"destructive\" });\n        setLoading(false);\n        return { success: false, message: \"Invalid server response.\" };\n      }\n      \n      console.log(`AuthProvider: API response from ${endpoint} - Status: ${response.status}, Data:`, data);\n\n      if (response.ok && data.user) {\n        console.log(`AuthProvider: API auth successful for ${endpoint}. User:`, data.user);\n        setUser(data.user);\n        setUserId(data.user.id);\n        toast({ title: data.message || (endpoint.includes('signup') ? \"Signup Successful\" : \"Login Successful\") });\n        // setLoading(false); // Set loading false *before* redirect - moved to finally\n        router.push('/'); // Redirect to dashboard on successful auth\n        return { success: true, message: data.message || \"Success\", user: data.user };\n      } else {\n        console.warn(`AuthProvider: API auth failed for ${endpoint}. Message:`, data.message);\n        toast({ title: data.message || \"Authentication Failed\", variant: \"destructive\" });\n        // setLoading(false); // - moved to finally\n        return { success: false, message: data.message || \"An error occurred\" };\n      }\n    } catch (error) {\n      console.error(`AuthProvider: Network or unexpected error during API auth at ${endpoint}:`, error);\n      const errorMessage = error instanceof Error ? error.message : \"Network error or server unavailable.\";\n      toast({ title: \"Error\", description: errorMessage, variant: \"destructive\" });\n      // setLoading(false); // - moved to finally\n      return { success: false, message: errorMessage };\n    } finally {\n        setLoading(false); // Ensure loading is always set to false\n    }\n  };\n\n  const handleSignIn = useCallback(\n    (email: string, password: string) => handleApiAuth('/api/auth/login', { email, password }),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [router, toast] \n  );\n\n  const handleSignUp = useCallback(\n    (email: string, password: string) => handleApiAuth('/api/auth/signup', { email, password }),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [router, toast] \n  );\n\n  const handleSignOut = useCallback(async () => {\n    console.log('AuthProvider: Attempting sign out...');\n    setLoading(true);\n    try {\n      await fetch('/api/auth/logout', { method: 'POST' });\n      setUser(null);\n      setUserId(null);\n      toast({ title: \"Signed Out\", description: \"You have been successfully signed out.\" });\n      router.push('/login');\n      console.log('AuthProvider: Sign out successful, redirected to /login.');\n    } catch (error) {\n      console.error(\"AuthProvider: Sign out error:\", error);\n      toast({ title: \"Sign Out Failed\", variant: \"destructive\" });\n    } finally {\n      setLoading(false);\n      console.log('AuthProvider: Sign out attempt finished, loading set to false.');\n    }\n  }, [router, toast]);\n\n  const getAllUsersForAdmin = useCallback(async (): Promise<{ id: string; email: string, createdAt: string }[] | null> => {\n    if (!isAdmin) { // Check against the derived isAdmin state\n      console.warn(\"AuthProvider: Attempted to get all users when not admin.\");\n      return null;\n    }\n    console.log('AuthProvider: Admin attempting to fetch all users...');\n    setLoading(true);\n    try {\n      const response = await fetch('/api/admin/users');\n      console.log('AuthProvider: Admin get users response status:', response.status);\n      if (!response.ok) {\n        const errorData = await response.json();\n        console.error('AuthProvider: Admin get users error data:', errorData);\n        throw new Error(errorData.message || `Failed to fetch users: ${response.statusText}`);\n      }\n      const data = await response.json();\n      console.log('AuthProvider: Admin get users success, user count:', data.users?.length);\n      return data.users;\n    } catch (error) {\n      console.error(\"AuthProvider: Error fetching all users for admin:\", error);\n      const errorMessage = error instanceof Error ? error.message : \"Could not load user data.\";\n      toast({ title: \"Admin Error\", description: errorMessage, variant: \"destructive\" });\n      return null;\n    } finally {\n      setLoading(false);\n      console.log('AuthProvider: Admin get users attempt finished, loading set to false.');\n    }\n  }, [isAdmin, toast]);\n\n\n  const value = useMemo(() => ({\n    user,\n    userId,\n    loading,\n    isAdmin,\n    signIn: handleSignIn,\n    signUp: handleSignUp,\n    signOut: handleSignOut,\n    getAllUsers: isAdmin ? getAllUsersForAdmin : undefined, // Conditionally provide getAllUsers\n  }), [user, userId, loading, isAdmin, handleSignIn, handleSignUp, handleSignOut, getAllUsersForAdmin]);\n\n  // This loader is a full-screen loader for initial auth state resolution.\n  // It should prevent content flicker.\n   if (loading && (pathname === '/login' || pathname === '/signup' || pathname === '/')) {\n     return (\n       <div className=\"flex justify-center items-center h-screen w-screen bg-background\">\n         <Loader2 className=\"w-12 h-12 animate-spin text-primary\" />\n         <span className=\"ml-3 text-muted-foreground\">Authenticating...</span>\n       </div>\n     );\n   }\n\n  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;\n};\n\nexport const useAuth = (): AuthContextType => {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 560, "column": 0}, "map": {"version":3,"sources":["file:///Users/tanishqbedi/Documents/Projects/kageyama/lifeos/src/lib/utils.ts"],"sourcesContent":["import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAEO,SAAS,GAAG,GAAG,MAAoB;IACxC,OAAO,CAAA,GAAA,8JAAA,CAAA,UAAO,AAAD,EAAE,CAAA,GAAA,wIAAA,CAAA,OAAI,AAAD,EAAE;AACtB","debugId":null}},
    {"offset": {"line": 579, "column": 0}, "map": {"version":3,"sources":["file:///Users/tanishqbedi/Documents/Projects/kageyama/lifeos/src/lib/local-storage.ts"],"sourcesContent":["// src/lib/local-storage.ts\n\n// --- Prefix and Key Definitions ---\nconst APP_PREFIX = 'lifeOS_';\n// USER_CREDENTIALS_PREFIX and SESSION_KEY are no longer needed here as auth moves to MongoDB/JWT\n// They will be managed by the server-side session logic (e.g., cookie names)\n\n// --- User Data Management (for application data like tasks, notes, etc.) ---\n\n/**\n * Saves data specific to the current user to localStorage.\n * Converts Date objects to ISO strings before saving.\n * @param userId The current user's ID.\n * @param keySuffix A suffix to identify the type of data (e.g., 'tasks', 'goals').\n * @param data The data to save.\n */\nexport function saveUserData<T>(userId: string, keySuffix: string, data: T): void {\n    if (typeof window === 'undefined' || !userId) {\n        console.warn(\"Attempted to save user data without userId or outside browser.\");\n        return;\n    }\n    try {\n        const key = `${APP_PREFIX}${userId}_${keySuffix}`;\n        const replacer = (k: string, value: any) => {\n            if (value instanceof Date) {\n                return value.toISOString();\n            }\n            return value;\n        };\n        localStorage.setItem(key, JSON.stringify(data, replacer));\n    } catch (error) {\n        console.error(`Error saving ${keySuffix} to localStorage for user ${userId}:`, error);\n        if (error instanceof DOMException && (error.name === 'QuotaExceededError' || error.message.includes('quota'))) {\n             alert(`Error: Browser storage is full. Cannot save ${keySuffix}. Please clear some space or remove old data.`);\n        }\n    }\n}\n\n/**\n * Loads data specific to the current user from localStorage.\n * Parses ISO date strings back into Date objects.\n * @param userId The current user's ID.\n * @param keySuffix A suffix to identify the type of data (e.g., 'tasks', 'goals').\n * @returns The loaded data or null if not found or error occurred.\n */\nexport function loadUserData<T>(userId: string, keySuffix: string): T | null {\n    if (typeof window === 'undefined' || !userId) {\n        console.warn(\"Attempted to load user data without userId or outside browser.\");\n        return null;\n    }\n    try {\n        const key = `${APP_PREFIX}${userId}_${keySuffix}`;\n        const dataJson = localStorage.getItem(key);\n        if (!dataJson) return null;\n\n        const reviver = (k: string, value: any) => {\n            if (typeof value === 'string') {\n                const isoDateRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([+-]\\d{2}:\\d{2}))$/;\n                if (isoDateRegex.test(value)) {\n                    const date = new Date(value);\n                    if (!isNaN(date.getTime())) {\n                        return date;\n                    }\n                }\n            }\n            return value;\n        };\n        return JSON.parse(dataJson, reviver) as T;\n    } catch (error) {\n        console.error(`Error loading ${keySuffix} from localStorage for user ${userId}:`, error);\n        return null;\n    }\n}\n\n\n/**\n * Deletes data specific to the current user from localStorage.\n * @param userId The current user's ID.\n * @param keySuffix A suffix to identify the type of data.\n */\nexport function deleteUserData(userId: string, keySuffix: string): void {\n    if (typeof window === 'undefined' || !userId) {\n        console.warn(\"Attempted to delete user data without userId or outside browser.\");\n        return;\n    }\n    try {\n        const key = `${APP_PREFIX}${userId}_${keySuffix}`;\n        localStorage.removeItem(key);\n    } catch (error) {\n        console.error(`Error deleting ${keySuffix} from localStorage for user ${userId}:`, error);\n    }\n}\n\n// The loadUsers function that read user credentials directly from localStorage is removed.\n// Admin user listing will now be handled by an API call to a protected endpoint\n// that queries MongoDB.\n\n\n// --- Generic Data Functions (Not user-specific, if any are needed) ---\n\n/**\n * Saves generic data to localStorage (not tied to a specific user).\n * @param keySuffix The key suffix to store the data under (will be prefixed).\n * @param data The data to save.\n */\nexport function saveGenericData<T>(keySuffix: string, data: T): void {\n    if (typeof window === 'undefined') return;\n    try {\n        localStorage.setItem(`${APP_PREFIX}${keySuffix}`, JSON.stringify(data));\n    } catch (error) {\n        console.error(`Error saving generic data for key ${keySuffix}:`, error);\n    }\n}\n\n/**\n * Loads generic data from localStorage.\n * @param keySuffix The key suffix the data is stored under (will be prefixed).\n * @returns The loaded data or null.\n */\nexport function loadGenericData<T>(keySuffix: string): T | null {\n    if (typeof window === 'undefined') return null;\n    try {\n        const dataJson = localStorage.getItem(`${APP_PREFIX}${keySuffix}`);\n        return dataJson ? JSON.parse(dataJson) : null;\n    } catch (error) {\n        console.error(`Error loading generic data for key ${keySuffix}:`, error);\n        return null;\n    }\n}\n"],"names":[],"mappings":"AAAA,2BAA2B;AAE3B,qCAAqC;;;;;;;;AACrC,MAAM,aAAa;AAaZ,SAAS,aAAgB,MAAc,EAAE,SAAiB,EAAE,IAAO;IACtE,IAAI,aAAkB,eAAe,CAAC,QAAQ;QAC1C,QAAQ,IAAI,CAAC;QACb;IACJ;IACA,IAAI;QACA,MAAM,MAAM,GAAG,aAAa,OAAO,CAAC,EAAE,WAAW;QACjD,MAAM,WAAW,CAAC,GAAW;YACzB,IAAI,iBAAiB,MAAM;gBACvB,OAAO,MAAM,WAAW;YAC5B;YACA,OAAO;QACX;QACA,aAAa,OAAO,CAAC,KAAK,KAAK,SAAS,CAAC,MAAM;IACnD,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,CAAC,aAAa,EAAE,UAAU,0BAA0B,EAAE,OAAO,CAAC,CAAC,EAAE;QAC/E,IAAI,iBAAiB,gBAAgB,CAAC,MAAM,IAAI,KAAK,wBAAwB,MAAM,OAAO,CAAC,QAAQ,CAAC,QAAQ,GAAG;YAC1G,MAAM,CAAC,4CAA4C,EAAE,UAAU,6CAA6C,CAAC;QAClH;IACJ;AACJ;AASO,SAAS,aAAgB,MAAc,EAAE,SAAiB;IAC7D,IAAI,aAAkB,eAAe,CAAC,QAAQ;QAC1C,QAAQ,IAAI,CAAC;QACb,OAAO;IACX;IACA,IAAI;QACA,MAAM,MAAM,GAAG,aAAa,OAAO,CAAC,EAAE,WAAW;QACjD,MAAM,WAAW,aAAa,OAAO,CAAC;QACtC,IAAI,CAAC,UAAU,OAAO;QAEtB,MAAM,UAAU,CAAC,GAAW;YACxB,IAAI,OAAO,UAAU,UAAU;gBAC3B,MAAM,eAAe;gBACrB,IAAI,aAAa,IAAI,CAAC,QAAQ;oBAC1B,MAAM,OAAO,IAAI,KAAK;oBACtB,IAAI,CAAC,MAAM,KAAK,OAAO,KAAK;wBACxB,OAAO;oBACX;gBACJ;YACJ;YACA,OAAO;QACX;QACA,OAAO,KAAK,KAAK,CAAC,UAAU;IAChC,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,CAAC,cAAc,EAAE,UAAU,4BAA4B,EAAE,OAAO,CAAC,CAAC,EAAE;QAClF,OAAO;IACX;AACJ;AAQO,SAAS,eAAe,MAAc,EAAE,SAAiB;IAC5D,IAAI,aAAkB,eAAe,CAAC,QAAQ;QAC1C,QAAQ,IAAI,CAAC;QACb;IACJ;IACA,IAAI;QACA,MAAM,MAAM,GAAG,aAAa,OAAO,CAAC,EAAE,WAAW;QACjD,aAAa,UAAU,CAAC;IAC5B,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,CAAC,eAAe,EAAE,UAAU,4BAA4B,EAAE,OAAO,CAAC,CAAC,EAAE;IACvF;AACJ;AAcO,SAAS,gBAAmB,SAAiB,EAAE,IAAO;IACzD,uCAAmC;;IAAM;IACzC,IAAI;QACA,aAAa,OAAO,CAAC,GAAG,aAAa,WAAW,EAAE,KAAK,SAAS,CAAC;IACrE,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,CAAC,kCAAkC,EAAE,UAAU,CAAC,CAAC,EAAE;IACrE;AACJ;AAOO,SAAS,gBAAmB,SAAiB;IAChD,uCAAmC;;IAAW;IAC9C,IAAI;QACA,MAAM,WAAW,aAAa,OAAO,CAAC,GAAG,aAAa,WAAW;QACjE,OAAO,WAAW,KAAK,KAAK,CAAC,YAAY;IAC7C,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,CAAC,mCAAmC,EAAE,UAAU,CAAC,CAAC,EAAE;QAClE,OAAO;IACX;AACJ","debugId":null}},
    {"offset": {"line": 680, "column": 0}, "map": {"version":3,"sources":["file:///Users/tanishqbedi/Documents/Projects/kageyama/lifeos/src/ai/flows/goal-breakdown-flow.ts"],"sourcesContent":["\n'use server';\n/**\n * @fileOverview AI-powered goal breakdown into actionable tasks.\n *\n * - breakDownGoalIntoTasks - Function to generate tasks from a goal description.\n * - BreakDownGoalInput - Input type for the breakDownGoalIntoTasks function.\n * - BreakDownGoalOutput - Return type for the breakDownGoalIntoTasks function.\n */\n\nimport { ai } from '@/ai/ai-instance';\nimport { z } from 'genkit';\n\n// --- Input Schema ---\nconst BreakDownGoalInputSchema = z.object({\n  goalName: z.string().describe('The name or title of the goal.'),\n  goalDescription: z.string().optional().describe('A detailed description of the goal (optional but recommended).'),\n  // Could add more context later, like existing tasks, user preferences etc.\n});\nexport type BreakDownGoalInput = z.infer<typeof BreakDownGoalInputSchema>;\n\n// --- Output Schema ---\nconst BreakDownGoalOutputSchema = z.object({\n  tasks: z.array(z.string()).describe('An array of suggested actionable task descriptions (strings) to achieve the goal.'),\n});\nexport type BreakDownGoalOutput = z.infer<typeof BreakDownGoalOutputSchema>;\n\n// --- Exported Wrapper Function ---\nexport async function breakDownGoalIntoTasks(input: BreakDownGoalInput): Promise<BreakDownGoalOutput> {\n  console.log(`[breakDownGoalIntoTasks] Request received for goal: ${input.goalName}`);\n  try {\n      const result = await breakDownGoalFlow(input);\n      console.log(`[breakDownGoalIntoTasks] Flow completed. Generated ${result.tasks?.length ?? 0} tasks.`);\n      return result;\n  } catch (error) {\n      console.error('[breakDownGoalIntoTasks] Error calling flow:', error);\n      throw error; // Re-throw for the calling component\n  }\n}\n\n// --- AI Prompt Definition ---\nconst prompt = ai.definePrompt({\n  name: 'breakDownGoalPrompt',\n  input: {\n    schema: BreakDownGoalInputSchema,\n  },\n  output: {\n    schema: BreakDownGoalOutputSchema,\n    format: 'json' // Ensure structured JSON output\n  },\n  prompt: `You are an expert productivity assistant specializing in breaking down goals into smaller, actionable tasks.\n\n  Goal Name: {{{goalName}}}\n  {{#if goalDescription}}\n  Goal Description: {{{goalDescription}}}\n  {{/if}}\n\n  Based on the provided goal name and description, generate a list of specific, actionable tasks that need to be completed to achieve this goal.\n  Each task should be a clear, concise instruction starting with an action verb (e.g., \"Research...\", \"Draft...\", \"Schedule...\", \"Complete...\").\n  Generate a reasonable number of tasks (typically 3-10) that represent the key steps. Avoid being overly granular or too high-level.\n\n  Respond ONLY with a JSON object containing a single key \"tasks\", which is an array of strings representing the task descriptions. Do not include any introductory text, explanations, or markdown formatting.\n\n  Example Input:\n  Goal Name: \"Learn React Basics\"\n  Goal Description: \"Understand core React concepts like components, state, props, and hooks to build simple web applications.\"\n\n  Example Output:\n  {\n    \"tasks\": [\n      \"Complete the official React tutorial (react.dev)\",\n      \"Build a simple counter application using useState hook\",\n      \"Create a component that accepts and displays props\",\n      \"Learn about conditional rendering in React\",\n      \"Experiment with the useEffect hook for side effects\",\n      \"Read documentation on React Router for navigation\"\n    ]\n  }\n\n  Now, generate the tasks for the provided goal.\n  `,\n  // Consider using a slightly more capable model if needed, but flash should be okay\n  // model: 'googleai/gemini-1.5-flash',\n});\n\n// --- Genkit Flow Definition ---\nconst breakDownGoalFlow = ai.defineFlow<\n  typeof BreakDownGoalInputSchema,\n  typeof BreakDownGoalOutputSchema\n>({\n  name: 'breakDownGoalFlow',\n  inputSchema: BreakDownGoalInputSchema,\n  outputSchema: BreakDownGoalOutputSchema,\n}, async (input) => {\n  console.log('[breakDownGoalFlow] Starting flow execution...');\n  try {\n    const { output, usage } = await prompt(input);\n    console.log('[breakDownGoalFlow] AI prompt call completed. Usage:', usage);\n\n    if (!output || !Array.isArray(output.tasks)) {\n      console.error('[breakDownGoalFlow] AI failed to return a valid response structure. Output:', output);\n      throw new Error(\"AI failed to generate tasks. Invalid response format.\");\n    }\n\n     // Filter out any empty strings just in case\n     const validTasks = output.tasks.filter(task => typeof task === 'string' && task.trim() !== '');\n\n    console.log(`[breakDownGoalFlow] Task generation successful. Found ${validTasks.length} valid tasks.`);\n    return { tasks: validTasks };\n\n  } catch (error) {\n    console.error('[breakDownGoalFlow] Error during prompt execution:', error);\n    throw new Error(`AI prompt failed: ${error instanceof Error ? error.message : String(error)}`);\n  }\n});\n\n// Wrapper function breakDownGoalIntoTasks is exported for use in server actions.\n"],"names":[],"mappings":";;;;;IA4BsB;CAwFtB,iFAAiF","debugId":null}},
    {"offset": {"line": 693, "column": 0}, "map": {"version":3,"sources":["file:///Users/tanishqbedi/Documents/Projects/kageyama/lifeos/src/ai/flows/generate-flashcards.ts"],"sourcesContent":["\n'use server';\n/**\n * @fileOverview AI-powered flashcard generation from PDF content.\n *\n * - generateFlashcardsFromPdf - A function that generates flashcards from a PDF data URI.\n * - GenerateFlashcardsInput - The input type for the generateFlashcardsFromPdf function.\n * - GenerateFlashcardsOutput - The return type for the generateFlashcardsFromPdf function.\n * - Flashcard - Type definition for a single flashcard.\n */\n\nimport {ai} from '@/ai/ai-instance';\nimport {z} from 'genkit';\n\n// Define schema for a single flashcard (internal, not exported)\nconst FlashcardSchema = z.object({\n  question: z.string().describe('The question or term on the front of the flashcard.'),\n  answer: z.string().describe('The answer or definition on the back of the flashcard.'),\n});\nexport type Flashcard = z.infer<typeof FlashcardSchema>; // Export the type\n\n// Define input schema (internal, not exported)\nconst GenerateFlashcardsInputSchema = z.object({\n  pdfDataUri: z\n    .string()\n    .describe(\n      \"The content of the PDF file, as a data URI that must include a MIME type (application/pdf) and use Base64 encoding. Expected format: 'data:application/pdf;base64,<encoded_data>'.\"\n    ),\n   instructions: z\n    .string()\n    .optional()\n    .describe('Optional custom instructions for the flashcard generation process (e.g., specific topics, difficulty).'),\n});\nexport type GenerateFlashcardsInput = z.infer<typeof GenerateFlashcardsInputSchema>; // Export the type\n\n// Define output schema (internal, not exported)\nconst GenerateFlashcardsOutputSchema = z.object({\n  flashcards: z.array(FlashcardSchema).describe('An array of generated flashcards.'),\n});\nexport type GenerateFlashcardsOutput = z.infer<typeof GenerateFlashcardsOutputSchema>; // Export the type\n\n// Exported wrapper function\nexport async function generateFlashcardsFromPdf(input: GenerateFlashcardsInput): Promise<GenerateFlashcardsOutput> {\n  console.log('[generateFlashcardsFromPdf] Received request. Validating input...');\n  // Validate that the data URI is for a PDF\n  if (!input.pdfDataUri || !input.pdfDataUri.startsWith('data:application/pdf;base64,')) {\n     console.error('[generateFlashcardsFromPdf] Invalid input: pdfDataUri is missing or not a base64 encoded PDF data URI.', input.pdfDataUri?.substring(0, 50));\n    throw new Error('Invalid input: pdfDataUri must be a base64 encoded PDF data URI starting with \"data:application/pdf;base64,\".');\n  }\n   console.log('[generateFlashcardsFromPdf] Input validated. Calling generateFlashcardsFlow...');\n  try {\n      const result = await generateFlashcardsFlow(input);\n      console.log(`[generateFlashcardsFromPdf] Flow completed successfully. Returning ${result.flashcards?.length ?? 0} cards.`);\n      return result;\n  } catch (error) {\n       console.error('[generateFlashcardsFromPdf] Error calling generateFlashcardsFlow:', error);\n       // Re-throw the error to be caught by the calling component\n       throw error;\n  }\n}\n\n// Define the prompt\nconst prompt = ai.definePrompt({\n  name: 'generateFlashcardsPrompt',\n  input: {\n    schema: GenerateFlashcardsInputSchema\n  },\n  output: {\n    schema: GenerateFlashcardsOutputSchema,\n    format: 'json' // Ensure the model outputs structured JSON\n  },\n  prompt: `You are an expert in creating effective study materials, specifically flashcards, from PDF documents.\n\n  Analyze the provided PDF document and generate a comprehensive set of flashcards. Each flashcard MUST have a clear question/term on the front and a corresponding accurate answer/definition on the back.\n  Focus on extracting **all** relevant key terms, definitions, concepts, important facts, and potential test questions found in the document.\n  Generate as many high-quality flashcards as the content supports. Do not impose an artificial limit on the number of cards.\n\n  {{#if instructions}}\n  Follow these specific instructions: {{{instructions}}}\n  {{else}}\n  Generate flashcards covering all main points and important details of the document.\n  {{/if}}\n\n  PDF Content:\n  {{media url=pdfDataUri}}\n\n  Generate the flashcards now based on the PDF content and instructions. Ensure the output is an array of objects, each with a 'question' and 'answer' field. Respond ONLY with the JSON object containing the 'flashcards' array. Do not include any introductory text or markdown formatting around the JSON.\n  `,\n  // Specify the model capable of processing PDFs (Gemini 1.5 Flash or Pro)\n  model: 'googleai/gemini-1.5-flash',\n});\n\n// Define the flow (internal, not exported directly for server actions)\nconst generateFlashcardsFlow = ai.defineFlow<\n  typeof GenerateFlashcardsInputSchema,\n  typeof GenerateFlashcardsOutputSchema\n>({\n  name: 'generateFlashcardsFlow',\n  inputSchema: GenerateFlashcardsInputSchema,\n  outputSchema: GenerateFlashcardsOutputSchema,\n}, async (input) => {\n  console.log('[generateFlashcardsFlow] Starting flow execution for PDF:', input.pdfDataUri.substring(0, 50) + \"...\"); // Log start\n\n  try {\n      console.log('[generateFlashcardsFlow] Calling AI prompt...');\n      const {output, usage} = await prompt(input);\n      console.log('[generateFlashcardsFlow] AI prompt call completed.');\n      console.log('[generateFlashcardsFlow] Usage:', usage);\n\n\n      // Validate the output structure\n      if (!output || !Array.isArray(output.flashcards)) {\n        console.error('[generateFlashcardsFlow] AI failed to return a valid response structure. Output received:', output);\n        throw new Error(\"AI failed to generate flashcards. Output was missing or invalid (expected { flashcards: [...] }).\");\n      }\n\n      // Validate individual flashcards (ensure both question and answer exist)\n      const validFlashcards = output.flashcards.filter(card =>\n          card &&\n          typeof card.question === 'string' && card.question.trim() !== '' &&\n          typeof card.answer === 'string' && card.answer.trim() !== ''\n      );\n      if (validFlashcards.length !== output.flashcards.length) {\n          const invalidCount = output.flashcards.length - validFlashcards.length;\n          console.warn(`[generateFlashcardsFlow] ${invalidCount} generated card(s) were invalid (missing question/answer) and filtered out. Original: ${output.flashcards.length}, Valid: ${validFlashcards.length}`);\n      }\n\n\n      console.log(`[generateFlashcardsFlow] Flashcards generation successful. Found ${validFlashcards.length} valid cards.`);\n      return { flashcards: validFlashcards }; // Return only the valid cards\n\n  } catch (error) {\n      console.error('[generateFlashcardsFlow] Error during prompt execution:', error);\n      // Check if the error is from the AI model itself (e.g., content filtering, API issues)\n      // This might require inspecting the error object structure provided by Genkit/GoogleAI\n      // if (error.isAiError) { ... }\n      throw new Error(`AI prompt failed: ${error instanceof Error ? error.message : String(error)}`); // Re-throw a more specific error\n  }\n});\n\n// IMPORTANT: Because this file uses 'use server', it CANNOT directly export the\n// result of ai.defineFlow. We export the wrapper function `generateFlashcardsFromPdf` instead.\n// The Genkit flow `generateFlashcardsFlow` is defined but only called internally by the wrapper.\n\n"],"names":[],"mappings":";;;;;IA0CsB;CAkGtB,gFAAgF;CAChF,+FAA+F;CAC/F,iGAAiG","debugId":null}},
    {"offset": {"line": 708, "column": 0}, "map": {"version":3,"sources":["file:///Users/tanishqbedi/Documents/Projects/kageyama/lifeos/src/ai/flows/generate-notes.ts"],"sourcesContent":["'use server';\n/**\n * @fileOverview AI-powered note generation from PDF content.\n *\n * - generateNotesFromPdf - A function that generates study notes from a PDF data URI.\n * - GenerateNotesInput - The input type for the generateNotesFromPdf function.\n * - GenerateNotesOutput - The return type for the generateNotesFromPdf function.\n * - NoteData - The structured data type for generated notes.\n */\n\nimport {ai} from '@/ai/ai-instance';\nimport {z} from 'genkit';\nimport type { NoteData } from '@/types'; // Import the structured NoteData type\n\n// Define input schema (internal, not exported)\nconst GenerateNotesInputSchema = z.object({\n  pdfDataUri: z\n    .string()\n    .describe(\n      \"The content of the PDF file, as a data URI that must include a MIME type (application/pdf) and use Base64 encoding. Expected format: 'data:application/pdf;base64,<encoded_data>'.\"\n    ),\n   instructions: z\n    .string()\n    .optional()\n    .describe('Optional custom instructions for the note generation process (e.g., focus areas, desired format, specific tags/category).'),\n});\nexport type GenerateNotesInput = z.infer<typeof GenerateNotesInputSchema>; // Export the type\n\n// Define output schema to match NoteData structure (internal, not exported)\nconst GenerateNotesOutputSchema = z.object({\n  content: z.string().describe('The generated study notes in markdown format.'),\n  tags: z.array(z.string()).describe('Suggested relevant tags for the notes (e.g., [\"Physics\", \"Quantum Mechanics\", \"Chapter 3\"]). Generate 3-5 relevant tags.'),\n  category: z.string().describe('A suggested single primary category for the notes (e.g., \"Physics\", \"Lecture Summary\", \"Study Guide\").'),\n});\n// Output type aligns with the main part of NoteData, generatedAt is added later\nexport type GenerateNotesOutput = z.infer<typeof GenerateNotesOutputSchema>; // Export the type\n\n// Exported wrapper function returns the full NoteData structure\nexport async function generateNotesFromPdf(input: GenerateNotesInput): Promise<NoteData> {\n  // Validate that the data URI is for a PDF\n  if (!input.pdfDataUri || !input.pdfDataUri.startsWith('data:application/pdf;base64,')) {\n    throw new Error('Invalid input: pdfDataUri must be a base64 encoded PDF data URI starting with \"data:application/pdf;base64,\".');\n  }\n  console.log('[generateNotesFromPdf] Input validated. Calling generateNotesFlow...');\n  try {\n      const result = await generateNotesFlow(input);\n      console.log('[generateNotesFromPdf] Flow completed successfully.');\n      // Add timestamp and return the full NoteData object\n      const fullNoteData: NoteData = {\n        ...result,\n        generatedAt: Date.now(),\n      };\n      return fullNoteData;\n  } catch (error) {\n      console.error('[generateNotesFromPdf] Error calling generateNotesFlow:', error);\n      throw error; // Re-throw\n  }\n}\n\nconst prompt = ai.definePrompt({\n  name: 'generateNotesPrompt',\n  input: {\n    schema: GenerateNotesInputSchema\n  },\n  output: {\n    schema: GenerateNotesOutputSchema,\n    format: 'json', // Ensure JSON output\n  },\n  prompt: `You are an expert academic assistant specializing in summarizing and creating structured study notes from PDF documents.\n\n  Analyze the provided PDF document and generate:\n  1. Comprehensive yet concise study notes in **Markdown format**. Cover key topics, concepts, definitions, and important details. Structure the notes logically using headings, bullet points, etc.\n  2. An array of 3-5 relevant **tags** (keywords) that accurately represent the note's content.\n  3. A single, relevant primary **category** for the notes.\n\n  {{#if instructions}}\n  Follow these specific instructions for content, tags, and category: {{{instructions}}}\n  {{else}}\n  Generate general study notes covering the main points, suitable tags, and an appropriate category.\n  {{/if}}\n\n  PDF Content:\n  {{media url=pdfDataUri}}\n\n  Generate the notes, tags, and category now based on the PDF content and instructions. Respond ONLY with a JSON object containing 'content', 'tags', and 'category' fields. Do not include any introductory text or markdown formatting around the JSON.\n  `,\n  // Specify the model capable of processing PDFs (Gemini 1.5 Flash or Pro)\n  model: 'googleai/gemini-1.5-flash', // Or 'googleai/gemini-1.5-pro' if flash is insufficient\n});\n\n// Internal flow definition\nconst generateNotesFlow = ai.defineFlow<\n  typeof GenerateNotesInputSchema,\n  typeof GenerateNotesOutputSchema // Flow returns the AI output structure\n>({\n  name: 'generateNotesFlow',\n  inputSchema: GenerateNotesInputSchema,\n  outputSchema: GenerateNotesOutputSchema,\n}, async input => {\n  console.log('[generateNotesFlow] Starting flow execution for PDF:', input.pdfDataUri.substring(0, 50) + \"...\"); // Log start\n  const {output, usage} = await prompt(input);\n  console.log('[generateNotesFlow] AI prompt call completed. Usage:', usage);\n\n   if (!output || typeof output.content !== 'string' || !Array.isArray(output.tags) || typeof output.category !== 'string') {\n      console.error('[generateNotesFlow] AI failed to return a valid response structure. Output received:', output);\n      throw new Error(\"AI failed to generate notes, tags, or category in the expected format.\");\n   }\n\n   // Basic validation for tags and category\n   const validTags = output.tags.filter(tag => typeof tag === 'string' && tag.trim() !== '');\n   const validCategory = output.category.trim() || 'Uncategorized'; // Default category if empty\n\n   console.log(`[generateNotesFlow] Notes generation successful. Content length: ${output.content.length}, Tags: ${validTags.join(', ')}, Category: ${validCategory}`);\n   // Return the structured data as defined by GenerateNotesOutputSchema\n   return {\n     content: output.content,\n     tags: validTags,\n     category: validCategory,\n   };\n});\n"],"names":[],"mappings":";;;;;IAsCsB","debugId":null}},
    {"offset": {"line": 720, "column": 0}, "map": {"version":3,"sources":["file:///Users/tanishqbedi/Documents/Projects/kageyama/lifeos/src/ai/flows/summarize-content-flow.ts"],"sourcesContent":["'use server';\n/**\n * @fileOverview AI-powered content summarization.\n *\n * - summarizeContent - Function to generate a summary from text content.\n * - SummarizeContentInput - Input type for the summarizeContent function.\n * - SummarizeContentOutput - Return type for the summarizeContent function (aligns with NoteData structure).\n */\n\nimport { ai } from '@/ai/ai-instance';\nimport { z } from 'genkit';\nimport type { NoteData } from '@/types'; // Import NoteData for output alignment\n\n// --- Input Schema ---\nconst SummarizeContentInputSchema = z.object({\n  textContent: z.string().min(50).describe('The text content to be summarized (at least 50 characters).'),\n  sourceUrl: z.string().url().optional().describe('Optional source URL of the content for context.'),\n  instructions: z.string().optional().describe('Optional custom instructions for the summarization process (e.g., desired length, key focus areas, target audience).'),\n});\nexport type SummarizeContentInput = z.infer<typeof SummarizeContentInputSchema>;\n\n// --- Output Schema (Matches NoteData structure for consistency) ---\nconst SummarizeContentOutputSchema = z.object({\n  content: z.string().describe('The generated summary in markdown format.'),\n  tags: z.array(z.string()).describe('Suggested relevant tags for the summary (e.g., [\"AI\", \"Summarization\", \"Article\"]). Generate 3-5 relevant tags.'),\n  category: z.string().describe('A suggested single primary category for the summary (e.g., \"Article Summary\", \"Research Notes\").'),\n  // generatedAt will be added by the calling function\n});\n// Output type aligns with the main part of NoteData\nexport type SummarizeContentOutput = z.infer<typeof SummarizeContentOutputSchema>;\n\n// --- Exported Wrapper Function (returns full NoteData) ---\nexport async function summarizeContent(input: SummarizeContentInput): Promise<NoteData> {\n  console.log('[summarizeContent] Request received.');\n  // Basic validation\n  if (!input.textContent || input.textContent.length < 50) {\n    throw new Error('Text content must be at least 50 characters long.');\n  }\n\n  try {\n    const result = await summarizeContentFlow(input);\n    console.log('[summarizeContent] Flow completed successfully.');\n    // Add timestamp and return the full NoteData object\n    const fullNoteData: NoteData = {\n      ...result,\n      generatedAt: Date.now(),\n    };\n    return fullNoteData;\n  } catch (error) {\n    console.error('[summarizeContent] Error calling flow:', error);\n    throw error; // Re-throw for the calling component\n  }\n}\n\n// --- AI Prompt Definition ---\nconst prompt = ai.definePrompt({\n  name: 'summarizeContentPrompt',\n  input: {\n    schema: SummarizeContentInputSchema,\n  },\n  output: {\n    schema: SummarizeContentOutputSchema,\n    format: 'json', // Ensure structured JSON output\n  },\n  prompt: `You are an expert summarization AI. Analyze the provided text content and generate:\n1. A concise and accurate summary in **Markdown format**. Capture the main points and key information.\n2. An array of 3-5 relevant **tags** (keywords) for the summary.\n3. A single, relevant primary **category** for the summary (e.g., \"Article Summary\", \"Meeting Notes\", \"Research Paper\").\n\n{{#if sourceUrl}}\nSource URL (for context): {{{sourceUrl}}}\n{{/if}}\n\n{{#if instructions}}\nFollow these specific instructions for the summary, tags, and category: {{{instructions}}}\n{{else}}\nGenerate a general summary covering the main points, appropriate tags, and a suitable category. Adjust summary length based on the input text length - be concise but comprehensive.\n{{/if}}\n\nText Content to Summarize:\n{{{textContent}}}\n\nGenerate the summary, tags, and category now. Respond ONLY with a JSON object containing 'content', 'tags', and 'category' fields. Do not include any introductory text or markdown formatting around the JSON.\n  `,\n  // Use a model capable of potentially longer context if needed\n  // model: 'googleai/gemini-1.5-flash',\n});\n\n// --- Genkit Flow Definition ---\nconst summarizeContentFlow = ai.defineFlow<\n  typeof SummarizeContentInputSchema,\n  typeof SummarizeContentOutputSchema // Flow returns the AI output structure\n>({\n  name: 'summarizeContentFlow',\n  inputSchema: SummarizeContentInputSchema,\n  outputSchema: SummarizeContentOutputSchema,\n}, async (input) => {\n  console.log('[summarizeContentFlow] Starting flow execution...');\n  try {\n    const { output, usage } = await prompt(input);\n    console.log('[summarizeContentFlow] AI prompt call completed. Usage:', usage);\n\n    if (!output || typeof output.content !== 'string' || !Array.isArray(output.tags) || typeof output.category !== 'string') {\n      console.error('[summarizeContentFlow] AI failed to return a valid response structure. Output:', output);\n      throw new Error(\"AI failed to generate summary, tags, or category in the expected format.\");\n    }\n\n    // Basic validation for tags and category\n    const validTags = output.tags.filter(tag => typeof tag === 'string' && tag.trim() !== '');\n    const validCategory = output.category.trim() || 'Summary'; // Default category if empty\n\n    console.log(`[summarizeContentFlow] Summary generation successful. Content length: ${output.content.length}, Tags: ${validTags.join(', ')}, Category: ${validCategory}`);\n    // Return the structured data as defined by SummarizeContentOutputSchema\n    return {\n      content: output.content,\n      tags: validTags,\n      category: validCategory,\n    };\n\n  } catch (error) {\n    console.error('[summarizeContentFlow] Error during prompt execution:', error);\n    throw new Error(`AI prompt failed: ${error instanceof Error ? error.message : String(error)}`);\n  }\n});\n"],"names":[],"mappings":";;;;;IAgCsB","debugId":null}},
    {"offset": {"line": 732, "column": 0}, "map": {"version":3,"sources":["file:///Users/tanishqbedi/Documents/Projects/kageyama/lifeos/src/ai/flows/answer-question.ts"],"sourcesContent":["'use server';\n\n/**\n * @fileOverview An AI assistant that answers user questions.\n *\n * - answerQuestion - A function that answers a question.\n * - AnswerQuestionInput - The input type for the answerQuestion function.\n * - AnswerQuestionOutput - The return type for the answerQuestion function.\n */\n\nimport {ai} from '@/ai/ai-instance';\nimport {z} from 'genkit';\n\n// Define input schema (internal, not exported)\nconst AnswerQuestionInputSchema = z.object({\n  question: z.string().describe('The question to answer.'),\n});\nexport type AnswerQuestionInput = z.infer<typeof AnswerQuestionInputSchema>; // Export the type\n\n// Define output schema (internal, not exported)\nconst AnswerQuestionOutputSchema = z.object({\n  answer: z.string().describe('The answer to the question.'),\n});\nexport type AnswerQuestionOutput = z.infer<typeof AnswerQuestionOutputSchema>; // Export the type\n\nexport async function answerQuestion(input: AnswerQuestionInput): Promise<AnswerQuestionOutput> {\n  return answerQuestionFlow(input);\n}\n\nconst answerQuestionPrompt = ai.definePrompt({\n  name: 'answerQuestionPrompt',\n  input: {\n    schema: AnswerQuestionInputSchema,\n  },\n  output: {\n    schema: AnswerQuestionOutputSchema,\n  },\n  prompt: `You are an AI assistant. Answer the following question: {{{question}}}`,\n});\n\nconst answerQuestionFlow = ai.defineFlow<\n  typeof AnswerQuestionInputSchema,\n  typeof AnswerQuestionOutputSchema\n>({\n  name: 'answerQuestionFlow',\n  inputSchema: AnswerQuestionInputSchema,\n  outputSchema: AnswerQuestionOutputSchema,\n}, async input => {\n  const {output} = await answerQuestionPrompt(input);\n  return output!;\n});\n\n"],"names":[],"mappings":";;;;;IAyBsB","debugId":null}},
    {"offset": {"line": 744, "column": 0}, "map": {"version":3,"sources":["file:///Users/tanishqbedi/Documents/Projects/kageyama/lifeos/src/ai/flows/generate-gemini-key.ts"],"sourcesContent":["\n'use server';\n\n/**\n * @fileOverview AI-powered Q&A assistant with Gemini key autogeneration (simulation).\n *\n * - generateGeminiKey - A function that handles the Gemini API key generation process (simulation).\n * - GenerateGeminiKeyInput - The input type for the generateGeminiKey function.\n * - GenerateGeminiKeyOutput - The return type for the generateGeminiKey function.\n */\n\nimport {ai} from '@/ai/ai-instance'; // Ensure this path is correct\nimport {z} from 'genkit';\n\n// Define input schema (internal, not exported)\nconst GenerateGeminiKeyInputSchema = z.object({\n  userDescription: z\n    .string()\n    .describe('Description of the user and their use case for the Gemini API key.'),\n});\nexport type GenerateGeminiKeyInput = z.infer<typeof GenerateGeminiKeyInputSchema>; // Export the type\n\n// Define output schema (internal, not exported)\nconst GenerateGeminiKeyOutputSchema = z.object({\n  geminiApiKey: z.string().describe('The \"generated\" (simulated) Gemini API key.'),\n  instructions: z.string().describe('Instructions on how to use a real Gemini API key, and a note about this being a simulation.'),\n});\nexport type GenerateGeminiKeyOutput = z.infer<typeof GenerateGeminiKeyOutputSchema>; // Export the type\n\nexport async function generateGeminiKey(input: GenerateGeminiKeyInput): Promise<GenerateGeminiKeyOutput> {\n  // No need to call a prompt for this simulation. We directly construct the output.\n  console.log('[generateGeminiKey] Simulating Gemini Key generation for user:', input.userDescription.substring(0, 50) + '...');\n  \n  // Generate a fake API key for demonstration\n  const fakeApiKey = `FAKE-AIzaSy${Math.random().toString(36).substring(2, 15)}${Math.random().toString(36).substring(2, 15)}`;\n  \n  const instructions = `\n**This is a SIMULATED API Key. It will NOT work with actual Google AI services.**\n\nTo use a real Gemini API key:\n1.  **Get a Real Key:** Visit the Google AI Studio (https://aistudio.google.com/app/apikey) to create an API key.\n2.  **Secure Your Key:** Keep your real API key secure! Do not share it publicly or commit it to code repositories.\n3.  **Environment Setup:** Store your real key in an environment variable (e.g., \\`GOOGLE_GENAI_API_KEY\\`) in your project's \\`.env\\` file.\n4.  **Usage:** Refer to the Gemini API documentation for specific usage instructions in your applications.\n5.  **Monitoring:** Monitor your API usage in the Google Cloud Console.\n`;\n\n  const output: GenerateGeminiKeyOutput = {\n    geminiApiKey: fakeApiKey,\n    instructions: instructions.trim(),\n  };\n  \n  console.log('[generateGeminiKey] Simulated key and instructions prepared.');\n  return output; // Directly return the simulated output\n}\n\n// The Genkit flow definition can be removed or commented out if not used,\n// as the exported function `generateGeminiKey` now handles the simulation directly.\n// If you intend to keep it for potential future integration with a real key generation service,\n// it would look something like this, but would require a tool or a model capable of this.\n\n/*\nconst prompt = ai.definePrompt({\n  name: 'generateGeminiKeyPrompt',\n  input: {\n    schema: GenerateGeminiKeyInputSchema,\n  },\n  output: {\n    schema: GenerateGeminiKeyOutputSchema,\n  },\n  prompt: \\`You are an AI assistant that can generate Gemini API keys for users.\n  Based on the user description, generate a Gemini API key and provide instructions on how to use it.\n  User Description: {{{userDescription}}}\n  \\`,\n  // This prompt would likely require a 'tool' to actually generate a key.\n});\n\nconst generateGeminiKeyFlow = ai.defineFlow<\n  typeof GenerateGeminiKeyInputSchema,\n  typeof GenerateGeminiKeyOutputSchema\n>({\n  name: 'generateGeminiKeyFlow',\n  inputSchema: GenerateGeminiKeyInputSchema,\n  outputSchema: GenerateGeminiKeyOutputSchema,\n}, async input => {\n  // In a real scenario, this would interact with a key generation service/tool\n  // For simulation, we're handling it in the exported function directly.\n  // const {output} = await prompt(input); // This would call the LLM\n  // return output!;\n  \n  // For this simulation, the flow would just call the direct logic.\n  // However, the exported function `generateGeminiKey` above bypasses this flow.\n  const fakeApiKey = \\`SIMULATED-KEY-\\${Date.now()}\\`;\n  const instructions = \"This is a simulated key. See Google AI Studio for real keys.\";\n  return { geminiApiKey: fakeApiKey, instructions };\n});\n*/\n"],"names":[],"mappings":";;;;;IA6BsB;CA2BtB,0EAA0E;CAC1E,oFAAoF;CACpF,gGAAgG;CAChG,0FAA0F;CAE1F;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA","debugId":null}},
    {"offset": {"line": 789, "column": 3}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}